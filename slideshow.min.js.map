{"version":3,"sources":["/source/slideshow.coffee","slideshow.js"],"names":["Slideshow","bind","clone","extend","indexOf","now","_ref","__slice","slice","__hasProp","hasOwnProperty","root","i","lastTime","vendor","vendors","length","requestAnimationFrame","cancelAnimationFrame","callback","currTime","id","timeToCall","Date","getTime","Math","max","setTimeout","clearTimeout","window","this","array","match","item","_i","_len","Array","prototype","call","object","objects","prop","target","arguments","fn","context","apply","element","options","nodeType","el","Error","configure","init","animateSlides","defaults","effects","eventEnd","eventProgress","eventStart","initEvents","initSlides","nextFrame","preventDefault","setCurrentSlide","_base","effect","conditions","concat","touchEventsEnabled","mouseEventsEnabled","preventDefaultEvents","animationDuration","animationDirection","default","transformCSSProperty","prefixed","style","_ref1","document","createElement","progress","time","durationModifier","before","slideState","slideElement","X","display","left","abs","after","effectAfter","effectBefore","slide","_ref2","_ref3","_ref4","_results","Function","slides","children","childNodes","current","push","TouchEvent","addEventListener","MouseEvent","currentSlide","targetSlide","_arg","direction","duration","durationMod","initialProgress","currentAnimation","currentEvent","cancelOnWillChange","onWillChange","start","anim","effectProgress","onDidChange","event","nextSlide","prevSlide","startX","startY","timeStamp","getCurrentSlide","getPrevSlide","getNextSlide","touches","pageX","pageY","nextIndex","x","clientWidth","y","clientHeight","shouldCancel","targetslide","_this","_ref5","condition","progressAbs","timePassed","_ref6","changedTouches","currentslide","Infinity","getSlide","getCurrentIndex","getFirstSlide","getLastSlide","goTo","cb","goToNext","goToPrev","goToFirst","goToLast","destroy","removeEventListener","registerAsJQueryPlugin","jQuery","methodName","container","registerEffect","name","define","amd","exports","module"],"mappings":"CAAC,WAAA,YAAA,IAAAA,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,KAAAC,MCIGC,KAAeC,gBDKhB,SAACC,GACF,GAAAC,GAAAC,EAAAC,EAAAC,EAAAT,CAGA,KAHAO,EAAW,EACXE,GAAY,KAAM,MAAO,SAAU,KACnCH,EAAI,EACEA,EAAIG,EAAQC,SAAWL,EAASM,uBACpCH,EAASC,EAAQH,KACjBD,EAAKM,sBAAwBN,EAAQG,EAAO,yBAC5CH,EAAKO,qBAAL,OAAAZ,EAAAK,EAAAG,EAAA,yBAAAR,EAAoEK,EAAQG,EAAO,8BAWrF,OARO,OAAAH,EAAAM,wBACLN,EAAKM,sBAAwB,SAACE,GAC5B,GAAAC,GAAAC,EAAAC,CCIE,ODJFF,IAAe,GAAAG,OAAOC,UACtBF,EAAaG,KAAKC,IAAI,EAAG,IAAMN,EAAWP,IAC1CQ,EAAKV,EAAKgB,WAAW,WCDjB,MDCqBR,GAASC,EAAWE,IAAaA,GAC1DT,EAAWO,EAAWE,EACtBD,IAEG,MAAAV,EAAAO,qBACLP,EAAKO,qBAAuB,SAACG,GCEzB,MDDFO,cAAaP,IAFjB,QAlBF,mBAAAQ,SAAA,OAAAA,OAAWA,OAASC,MA0BpB1B,EAAU,SAAC2B,EAAOC,GAChB,GAAApB,GAAAqB,EAAAC,EAAAC,CAAA,IAAc,MAAAJ,EAAd,CACA,GAAG,MAAAK,MAAAC,UAAAjC,QACD,MAAOgC,OAAKC,UAAEjC,QAAQkC,KAAKF,MAAKC,UAAE7B,MAAM8B,KAAKP,GAAQC,EACvD,KAAApB,EAAAsB,EAAA,EAAAC,EAAAJ,EAAAf,OAAAmB,EAAAD,EAAAtB,IAAAsB,ECMI,GADAD,EAAOF,EAAMnB,GDLSqB,IAAQD,EAChC,MAAOpB,ECSP,ODRF,KAIFT,EAAS,WACP,GAAAoC,GAAAC,EAAAC,EAAAC,EAAAR,EAAAC,CAAA,IADQO,EAAAC,UAAA,GAAQH,EAAA,GAAAG,UAAA3B,OAAAT,EAAA+B,KAAAK,UAAA,MACgB,gBAAlBD,GAAd,CACA,IAAAR,EAAA,EAAAC,EAAAK,EAAAxB,OAAAmB,EAAAD,EAAAA,IAAA,CCYIK,EAASC,EAAQN,EDXnB,KAAAO,IAAAF,GCaS9B,EAAU6B,KAAKC,EAAQE,KDZ9BC,EAAOD,GAAQF,EAAOE,ICgBxB,MDfFC,KAIFxC,EAAQ,SAACqC,GCeL,MDfgBpC,MAAWoC,IAI/BtC,EAAO,SAAC2C,EAAIC,GCeR,MDfoB,YCgBlB,MDhBqBD,GAAGE,MAAMD,KAAYrC,MAAM8B,KAAKK,cAE3DtC,EAAA,OAAAC,EAAAiB,KAAAlB,KAAAC,EAAiB,WCmBb,ODnBoB,GAAAiB,OAAOC,WAEzBxB,EAAA,WACS,QAAAA,GAAC+C,EAASC,GAMrB,GCiBiB,MAAXA,IDvBeA,MAGM,IAApBD,EAAQE,WACV,MAAAF,EAAA,KAAiBA,EAAUA,EAAQ,IACnC,MAAAA,EAAAG,KAAiBH,EAAUA,EAAQG,KACf,IAAtBH,EAAQE,SACT,KAAU,IAAAE,OAAO,4BACnBrB,MAACsB,UAAUJ,GACXlB,KAACoB,GAAKH,EAENM,EAAKf,KAAKR,MAXZ,GAAAwB,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAN,EAAAO,EAAAC,EAAAC,EAAAC,EAAAC,CCmhBE,ODnhBFhE,GAAAqC,UAaAe,UAAW,SAACJ,GACV,GAAAiB,EACA,OADAnC,MAACkB,QAAU7C,KAAWoD,EAAUP,GACF,gBAA3BlB,MAAQkB,QAAQkB,QAAuB,MAAAV,EAAA1B,KAAAkB,QAAAkB,SACxCpC,KAACkB,QAAQkB,OAAShE,EAAMsD,EAAQ1B,KAACkB,QAAQkB,SC+BY,OAA3CD,EAAQnC,KAAKkB,QAAQkB,QAAQC,WAAqBF,ED9B5CE,WAAAF,EAAAE,WAAcX,EAAQ,WAAQW,WAAWC,UAF3D,QAMFb,GACEc,oBAAoB,EACpBC,oBAAoB,EACpBC,sBAAsB,EACtBC,kBAAmB,IACnBC,mBAAqB,IACrBP,OAAS,WAEXV,GACEkB,UAAY,WAEV,GAAAC,EC+CE,OD/CFA,GAA0B,WACxB,GAAAC,GAAAC,EAAA/D,EAAAoB,EAAAC,EAAA2C,CACA,IADAD,EAAQE,SAASC,cAAe,OAAMH,MAChB,MAAAA,EAAA,UAAtB,MAAQ,WACR,KAAAC,GAAA,MAAA,SAAA,QAAA,IAAA,MAAA5C,EAAA,EAAAC,EAAA2C,EAAA9D,OAAAmB,EAAAD,EAAAA,IAEE,GCkCEpB,EAASgE,EAAM5C,GDnCjB0C,EAAc9D,EAAO,YACF,MAAA+D,EAAAD,GAAnB,MAAOA,ECwCP,QDvCF,MAEFT,aACEc,SAAU,GACVC,KAAM,IACNC,iBAAkB,KAElBF,SAAU,GACVC,KAAM,MAEND,SAAU,KAEZG,OAAQ,SAACC,EAAYC,GACnB,GAAAC,EAQA,OARAD,GAAaT,MAAMW,QAAW,QAO9BD,EAAkB,KAAdF,EACDV,EACDW,EAAaT,MAAMF,GAAyB,cAAaY,EAAE,KAE3DD,EAAaT,MAAMY,KAAUF,EAAE,KACnCN,SAAU,SAACI,EAAYJ,EAAUK,GAC/B,GAAAC,EAsBA,OADAA,GAAI,IAAMN,GAAY,EAAII,EAAa5D,KAAKiE,IAAIT,IAC7CN,EACDW,EAAaT,MAAMF,GAAyB,cAAaY,EAAE,KAE3DD,EAAaT,MAAMY,KAAUF,EAAE,KACnCI,MAAO,SAACN,EAAYC,GCyDd,MDnDJA,GAAaT,MAAMW,QAAaH,EAAa,EAAQ,QAAa,aAExEhC,EAAO,WCyDH,MDxDFQ,GAAWvB,KAAKR,MAChB8B,EAAWtB,KAAKR,OAElB+B,EAAa,WAEX,GAAA+B,GAAAC,EAAAjF,EAAAkF,EAAA5D,EAAAC,EAAA2C,EAAAiB,EAAAC,EAAAC,EAAAC,CC8DE,KD9DFL,EAAA,OAAAf,EAAAhD,KAAAkB,QAAAkB,OAAAkB,QAAAN,EAAwCqB,SAAS9D,UACjDuD,EAAA,OAAAG,EAAAjE,KAAAkB,QAAAkB,OAAAyB,OAAAI,EAAsCI,SAAS9D,UAE/CP,KAACsE,OAAD,OAAAJ,EAAAlE,KAAAoB,GAAAmD,UAAAL,EAAyBlE,KAACoB,GAAGoD,WAC7BxE,KAACyE,QAAU,EACXN,EAAAnE,KAAAsE,OAAAF,KAAAtF,EAAAsB,EAAA,EAAAC,EAAA8D,EAAAjF,OAAAmB,EAAAD,EAAAtB,IAAAsB,EC0DI4D,EAAQG,EAAMrF,GD1DWA,IAAOkB,KAACyE,UAGhC3F,IAAKkB,KAACyE,SACPV,EAAavD,KAAKR,KAAG,EAAGA,KAACsE,OAAOtE,KAACyE,UAAjCL,EAAAM,KACAZ,EAAYtD,KAAKR,KAAG,EAAGA,KAACsE,OAAOtE,KAACyE,aAEhCV,EAAavD,KAAKR,KAAG,EAAGgE,GAAxBI,EAAAM,KACAZ,EAAYtD,KAAKR,KAAG,EAAGgE,KC6DzB,OAAOI,ID3DXtC,EAAa,WACX,GAAAkC,GAAA5D,EAAAC,EAAA2C,EAAAoB,CASA,IATApE,KAAC6B,WAAa1D,EAAK0D,EAAY7B,MAC/BA,KAAC4B,cAAgBzD,EAAKyD,EAAe5B,MACrCA,KAAC2B,SAAWxD,EAAKwD,EAAU3B,MAExB,mBAAA2E,aAAA,OAAAA,YAAgB3E,KAACkB,QAAQqB,qBAC1BvC,KAACoB,GAAGwD,iBAAkB,aAAa5E,KAAC6B,YACpC7B,KAACoB,GAAGwD,iBAAkB,YAAY5E,KAAC4B,eACnC5B,KAACoB,GAAGwD,iBAAkB,WAAW5E,KAAC2B,WAEjC,mBAAAkD,aAAA,OAAAA,YAAgB7E,KAACkB,QAAQsB,mBAA5B,CCqEI,IDpEFxC,KAACoB,GAAGwD,iBAAkB,YAAY5E,KAAC6B,YACnC7B,KAACoB,GAAGwD,iBAAkB,YAAY5E,KAAC4B,eACnC5B,KAACoB,GAAGwD,iBAAkB,UAAU5E,KAAC2B,UACjC3B,KAACoB,GAAGwD,iBAAkB,aAAa5E,KAAC2B,UACpCqB,EAAAhD,KAAAsE,OAAAF,KAAAhE,EAAA,EAAAC,EAAA2C,EAAA9D,OAAAmB,EAAAD,EAAAA,ICiEI4D,EAAQhB,EAAM5C,GDhEhB4D,EAAMY,iBAAkB,YAAY3C,GACpC+B,EAAMY,iBAAkB,YAAY3C,GADpCmC,EAAAM,KAEAV,EAAMY,iBAAkB,UAAU3C,GCmElC,OAAOmC,KDjEblC,EAAkB,SAAC8B,GCsEf,MDpEFhE,MAACyE,QAAUnG,EAAQ0B,KAACsE,OAAQN,IAE9BxC,EAAgB,SAACsD,EAAcC,EAAaC,EAA2C3F,GAErF,GAAA4F,GAAAC,EAAAC,EAAApB,EAAAqB,EAAAjC,EAAAH,EAAAiB,CAAA,OAF2CgB,GAAAD,EAAAC,UAAWG,EAAAJ,EAAAI,gBAAiBD,EAAAH,EAAAG,YAE7D,MAAAnF,KAAAqF,kBAEH,MAAArF,KAAAsF,cAAmBtF,KAACsF,aAAaC,oBCwEO,OAAtCvC,EAAQhD,KAAKkB,QAAQsE,eACxBxC,EDxEmBxC,KAAKR,KAAG8E,EAAcC,GAAc/E,KAACyE,QAAU,GAAKzE,KAACsE,OAAOpF,QAErFiE,EAAA,MAAAiC,EAAWA,EAAkB,EC0ER,MAAfD,IDzENA,EAAe,GAEfD,EAAWvF,KAAKC,IAAI,EAAGI,KAACkB,QAAQwB,mBAAqB,EAAIS,GAAYgC,GAG9D,MAAAnF,KAAAsF,eACLvB,EAAA,OAAAE,EAAAjE,KAAAkB,QAAAkB,OAAAkB,QAAAW,EAAwCI,SAAS9D,UACjDwD,EAAavD,KAAKR,KAAG,EAAG8E,GACxBf,EAAavD,KAAKR,KAAmB,EAAZiF,EAAmB,EAAO,GAAKF,IAE1D/E,KAACqF,kBAAoBI,MAAOlH,IAAOuG,aAAAA,EAAcC,YAAAA,EAAaE,UAAAA,EAAWC,SAAAA,EAAU/B,SAAAA,EAAU9D,SAAAA,GAE7FF,sBAAsBhB,EAAK6D,EAAWhC,QAlBtC,QAoBFgC,EAAY,WAEV,GAAA0D,GAAArG,EAAAyF,EAAAG,EAAAC,EAAApB,EAAA6B,EAAApG,EAAA4D,EAAAsC,EAAAV,EAAA/B,EAAAiB,EAAAC,EAAAC,CCsGE,ODtGF5E,GAAKJ,sBAAsBhB,EAAK6D,EAAWhC,OAC3C0F,EAAO1F,KAACqF,iBACRrC,EAA8EhD,KAACqF,iBAA9EI,EAAAzC,EAAAyC,MAAOtC,EAAAH,EAAAG,SAAU+B,EAAAlC,EAAAkC,SAAUD,EAAAjC,EAAAiC,UAAWH,EAAA9B,EAAA8B,aAAcC,EAAA/B,EAAA+B,YAAa1F,EAAA2D,EAAA3D,SAElE8D,IAAuB5E,IAAQkH,GAASP,GAAY,EAAI/B,GACrDA,GAAY,IACbA,EAAW,EAEXnD,KAACqF,iBAAmB,KACpBjG,qBAAqBG,GAErBuE,EAAA,OAAAG,EAAAjE,KAAAkB,QAAAkB,OAAAyB,OAAAI,EAAsCI,SAAS9D,UAC/CuD,EAAYtD,KAAKR,KAAG,EAAG8E,GACvBhB,EAAYtD,KAAKR,KAAG,EAAG+E,GAEvB7C,EAAgB1B,KAAKR,KAAG+E,GC6EN,MAAZ1F,GD5ENA,EAAUmB,KAAKR,KAAG8E,EAAcC,EAAa/E,KAACyE,SC+EF,OAArCP,EAAQlE,KAAKkB,QAAQ0E,cACxB1B,ED/EkB1D,KAAKR,KAAG8E,EAAcC,EAAa/E,KAACyE,SAC1DvC,EAAgB1B,KAAKR,KAAG+E,IAE1BY,EAAA,OAAAxB,EAAAnE,KAAAkB,QAAAkB,OAAAe,UAAAgB,EAA4CE,SAAS9D,UACrDoF,EAAenF,KAAKR,KAAG,EAAGmD,EAAW8B,EAAWH,GAChDa,EAAenF,KAAKR,KAAG,EAAGmD,EAAW8B,EAAWF,IAElDlD,EAAa,SAACgE,GACZ,GAAAf,GAAAf,EAAA+B,EAAAC,EAAAC,EAAAC,EAAAC,EAAAlD,EAAAiB,EAAAC,EAAAC,CAGA,OAHGnE,MAACkB,QAAQuB,sBACVoD,EAAM5D,iBAEE,MAAAjC,KAAAqF,kBAAsB,MAAArF,KAAAsF,cAEhCR,EAAe9E,KAACmG,kBAChBJ,EAAY/F,KAACoG,eACbN,EAAY9F,KAACqG,eAEbtC,EAAA,OAAAf,EAAAhD,KAAAkB,QAAAkB,OAAAkB,QAAAN,EAAwCqB,SAAS9D,UACjDwD,EAAavD,KAAKR,KAAG,EAAG8E,GACxBf,EAAavD,KAAKR,KAAG,GAAI+F,GACzBhC,EAAavD,KAAKR,KAAG,EAAG8F,GAEvBI,EAAaL,EAAbK,UACD/B,EAAA,OAAAF,EAAA,OAAAC,EAAA2B,EAAAS,SAAApC,EAAA,GAAA,QAAAD,EAAqD4B,EAA7CG,EAAA7B,EAAPoC,MAAsBN,EAAA9B,EAAPqC,MAChBxG,KAACsF,cAAgBR,aAAAA,EAAciB,UAAAA,EAAWD,UAAAA,EAAWI,UAAAA,EAAWF,OAAAA,EAAQC,OAAAA,IAbxE,QAeFrE,EAAgB,SAACiE,GACf,GAAAY,GAAAF,EAAAC,EAAArD,EAAA4B,EAAA/B,EAAAiB,EAAAC,EAAAC,CAGA,OAHGnE,MAACkB,QAAQuB,sBACVoD,EAAM5D,iBAEEjC,KAACqF,kBAAwB,MAAArF,KAAAsF,eACnCpB,EAAA,OAAAlB,EAAA,OAAAiB,EAAA4B,EAAAS,SAAArC,EAAA,GAAA,QAAAjB,EAAqC6C,EAApCU,EAAArC,EAAAqC,MAAOC,EAAAtC,EAAAsC,MAKRrD,GACEuD,GAAIH,EAAQvG,KAACsF,aAAaU,QAAUhG,KAACoB,GAAGuF,YACxCC,GAAIJ,EAAQxG,KAACsF,aAAaW,QAAUjG,KAACoB,GAAGyF,cAC1C1D,EAAA,WAAW,OAAOnD,KAACkB,QAAQyB,oBAAhB,IACH,IACJ,GAAGhD,KAAKiE,IAAIT,EAASuD,GAAK/G,KAAKiE,IAAIT,EAASyD,GC2FtC,MD3F8CzD,GAASuD,CADzD,MADG,KAGH,IACJ,GAAG/G,KAAKiE,IAAIT,EAASyD,GAAKjH,KAAKiE,IAAIT,EAASuD,GC8FtC,MD9F8CvD,GAASyD,ICiG5DpG,KAAKR,MDhGVA,KAACsF,aAAawB,cAAe3D,EACf,MAAAA,GAfd,QAiBA4B,EAA4B,EAAX5B,EAAkBnD,KAACsF,aAAaQ,UAAe9F,KAACsF,aAAaS,UAC3EhB,IAAiB/E,KAACsF,aAAaP,cAChC/E,KAACsF,aAAaC,oBAAqB,EACnCvF,KAACsF,aAAayB,YAAchC,GAEvB/E,KAACsF,aAAaC,oBAAqC,IAAdpC,IAC1CnD,KAACsF,aAAaC,oBAAqB,EACnCkB,GAAazG,KAACyE,QAAUtB,EAAWxD,KAAKiE,IAAIT,IAAYnD,KAACsE,OAAOpF,OCmGnB,OAAtCiF,EAAQnE,KAAKkB,QAAQsE,eACxBrB,EDnGmB3D,KAAKR,KAAGA,KAACsF,aAAaR,aAAcC,GAAc/E,KAACyE,QAAUtB,EAAWxD,KAAKiE,IAAIT,IAAYnD,KAACsE,OAAOpF,SAC9Hc,KAACsF,aAAaP,YAAcA,EAE5B5F,sBAAsB,SAAA6H,GCqGlB,MDrGkB,YACpB,GAAArB,GAAAsB,CCwGI,ODxGJtB,GAAA,OAAAsB,EAAAD,EAAA9F,QAAAkB,OAAAe,UAAA8D,EAA4C5C,SAAS9D,UACrDoF,EAAenF,KAAKwG,EAAG,EAAG7D,EAAU6D,EAAC1B,aAAaR,cAClDa,EAAenF,KAAKwG,EAAG,EAAG7D,EAAU4B,KAHhB/E,SAKxB2B,EAAW,SAACkE,GACV,GAAAqB,GAAApC,EAAAG,EAAAE,EAAAC,EAAAmB,EAAAC,EAAArD,EAAAgE,EAAApC,EAAAqC,EAAAlB,EAAA9F,EAAAC,EAAA2C,EAAAiB,EAAAC,EAAAC,EAAA8C,EAAAI,CAGA,IAHGrH,KAACkB,QAAQuB,sBACVoD,EAAM5D,kBAEEjC,KAACqF,kBAAwB,MAAArF,KAAAsF,aAAnC,CAOA,GANCY,EAAaL,EAAbK,UACDhC,EAAA,OAAAlB,EAAA,OAAAiB,EAAA4B,EAAAyB,gBAAArD,EAAA,GAAA,QAAAjB,EAA4C6C,EAA3CU,EAAArC,EAAAqC,MAAOC,EAAAtC,EAAAsC,MAERrD,EAAA,WAAW,OAAOnD,KAACkB,QAAQyB,oBAAhB,IACH,IC6GA,OD7GS4D,EAAQvG,KAACsF,aAAaU,QAAUhG,KAACoB,GAAGuF,WAD1C,KAEH,IC8GA,OD9GSH,EAAQxG,KAACsF,aAAaW,QAAUjG,KAACoB,GAAGyF,eCgHhDrG,KAAKR,MD/GPA,KAACsF,aAAawB,aAMf,MALAhC,GAAkB3B,EAAW,EAAOnD,KAACsF,aAAaQ,UAAe9F,KAACsF,aAAaS,UAC/Ed,EAAY9B,EAAWxD,KAAKiE,IAAIT,GAChCiC,EAAkB,EAAIzF,KAAKiE,IAAIT,GAC/B3B,EAAchB,KAAKR,KAAGuH,aAAcvH,KAACsF,aAAaR,cAAeG,UAAAA,EAAWG,gBAAAA,SAC5EpF,KAACsF,aAAe,KAElB,IAAe,IAAZnC,EAED,YADAnD,KAACsF,aAAe,KAMlB,KAHA8B,EAAalB,EAAYlG,KAACsF,aAAaY,UACvCiB,EAAcxH,KAAKiE,IAAIT,GAEvBgB,EAAAnE,KAAAkB,QAAAkB,OAAAC,WAAAjC,EAAA,EAAAC,EAAA8D,EAAAjF,OAAAmB,EAAAD,EAAAA,IACE,GCoHE8G,EAAY/C,EAAM/D,GDpHjB+G,EAAcD,EAAU/D,UAAaiE,GAAa,OAAAH,EAAAC,EAAA9D,MAAA6D,EAAkBO,KAAvE,CAEErC,EAAA,OAAAkC,EAAAH,EAAA7D,kBAAAgE,EAA2C,CAC3C,OC0IF,MDvIC,OAAAlC,GAIDL,EAAe9E,KAACsF,aAAaR,aAC7BG,EAAY9B,EAAWgE,EAErBpC,EADc,IAAbE,EACajF,KAACsF,aAAaS,UAEd/F,KAACsF,aAAaQ,UAC9BV,EAAkB+B,IAKlBpC,EAAc/E,KAACsF,aAAaR,aAC5BG,GAAY9B,EAAYgE,EAEtBrC,EADc,IAAbG,EACcjF,KAACsF,aAAaQ,UAEd9F,KAACsF,aAAaS,UAC/BX,EAAkB,EAAI+B,GAExB3F,EAAchB,KAAKR,KAAG8E,EAAcC,GAAcE,UAAAA,EAAWG,gBAAAA,EAAiBD,YAAAA,GAAc,SAAA6B,GCqHxF,MDrHwF,YCsHtF,MDrHJA,GAAC1B,aAAe,OAD0EtF,SAG9FiC,EAAiB,SAAC4D,GCyHd,MDxHFA,GAAM5D,kBAlTR/D,EAAAqC,UA6TAkH,SAAU,SAAC3I,GCqHP,MDpHFA,IAAQkB,KAACsE,OAAOpF,OACT,EAAJJ,IAAWA,GAAKkB,KAACsE,OAAOpF,QAC3Bc,KAACsE,OAAOxF,IAhUVZ,EAAAqC,UAmUA4F,gBAAiB,WCmHb,MDnHgBnG,MAACsE,OAAOtE,KAACyE,UAnU7BvG,EAAAqC,UAqUAmH,gBAAiB,WCqHb,MDrHgB1H,MAACyE,SArUrBvG,EAAAqC,UAwUA8F,aAAc,WCsHV,MDtHarG,MAACyH,SAASzH,KAACyE,QAAU,IAxUtCvG,EAAAqC,UA2UA6F,aAAc,WCuHV,MDvHapG,MAACyH,SAASzH,KAACyE,QAAU,IA3UtCvG,EAAAqC,UA8UAoH,cAAe,WCwHX,MDxHc3H,MAACsE,OAAO,IA9U1BpG,EAAAqC,UAiVAqH,aAAc,WCyHV,MDzHa5H,MAACsE,OAAOtE,KAACsE,OAAOpF,OAAS,IAjV1ChB,EAAAqC,UAsVAsH,KAAM,SAAC/I,EAAGgJ,GACR,GAAAhD,GAAAG,EAAAF,CAAA,IAAUjG,IAAKkB,KAACyE,QC8Hd,MD7HFK,GAAe9E,KAACmG,kBAChBpB,EAAc/E,KAACyH,SAAS3I,GAExBmG,EAAenG,EAAIkB,KAACyE,QAAa,EAAO,GACxCjD,EAAchB,KAAKR,KAAG8E,EAAcC,GAAcE,UAAAA,GAAY6C,IA5VhE5J,EAAAqC,UA+VAwH,SAAU,SAACD,GC4HP,MD5Hc9H,MAAC6H,KAAK7H,KAACyE,QAAU,EAAGqD,IA/VtC5J,EAAAqC,UAkWAyH,SAAU,SAACF,GC6HP,MD7Hc9H,MAAC6H,KAAK7H,KAACyE,QAAU,EAAGqD,IAlWtC5J,EAAAqC,UAqWA0H,UAAW,SAACH,GC8HR,MD9He9H,MAAC6H,KAAK,EAAGC,IArW5B5J,EAAAqC,UAwWA2H,SAAU,SAACJ,GC+HP,MD/Hc9H,MAAC6H,KAAK7H,KAACsE,OAAOpF,OAAS,EAAG4I,IAxW5C5J,EAAAqC,UA2WA4H,QAAS,WACP,GAAAnE,GAAA5D,EAAAC,EAAA2C,EAAAiB,CAOA,KAPAjE,KAACoB,GAAGgH,oBAAqB,aAAapI,KAAC6B,YACvC7B,KAACoB,GAAGgH,oBAAqB,YAAYpI,KAAC4B,eACtC5B,KAACoB,GAAGgH,oBAAqB,WAAWpI,KAAC2B,UACrC3B,KAACoB,GAAGgH,oBAAqB,YAAYpI,KAAC6B,YACtC7B,KAACoB,GAAGgH,oBAAqB,YAAYpI,KAAC4B,eACtC5B,KAACoB,GAAGgH,oBAAqB,UAAUpI,KAAC2B,UACpC3B,KAACoB,GAAGgH,oBAAqB,aAAapI,KAAC2B,UACvCqB,EAAAhD,KAAAsE,OAAAlE,EAAA,EAAAC,EAAA2C,EAAA9D,OAAAmB,EAAAD,EAAAA,ICkII4D,EAAQhB,EAAM5C,GDjIhB4D,EAAMoE,oBAAqB,YAAYnG,GACvC+B,EAAMoE,oBAAqB,YAAYnG,GACvC+B,EAAMoE,oBAAqB,UAAUnG,ECoIrC,ODnIFgC,MAACjE,KAACoB,GAAA6C,EAAA7C,GAAIpB,KAACsE,OAAAL,EAAAK,OAAQtE,KAAC6B,WAAAoC,EAAApC,WAAY7B,KAAC4B,cAAAqC,EAAArC,cAAe5B,KAAC2B,SAAAsC,EAAAtC,SAAU3B,KAACkB,QAAA+C,EAAA/C,QAAxD+C,GAIF/F,EAACmK,uBAAwB,SAACC,EAAQC,GCsI9B,MAHkB,OAAdA,IDnI0BA,EAAc,aAC9CD,EAAOxH,GAAGyH,GAAc,SAACrH,GAAY,GAAAsH,GAAApI,EAAAC,EAAA+D,CCwIjC,KDxIkCA,KAAAhE,EAAA,EAAAC,EAAAL,KAAAd,OAAAmB,EAAAD,EAAAA,ICyIhCoI,EAAYxI,KAAKI,GDzIegE,EAAAM,KAAI,GAAAxG,GAAUsK,EAAWtH,GC4I3D,OAAOkD,KD1IblG,EAACuK,eAAgB,SAACC,EAAMtG,GCkJpB,MAHyB,OAArBA,EAAOC,aD9IbD,EAAOC,WAAcX,EAAQ,WAAQW,WAAWC,UCiJtB,MAAjBZ,EAAQgH,GDhJjBhH,EAAQgH,GAARhH,EAAQgH,GAAStG,GCmJVlE,KDhJR,SAACW,GAEF,MAAqB,kBAAlB8J,SAAgCA,OAAOC,IACxCD,UAAW,WCoJP,MDpJUzK,KAEa,mBAArB2K,SACNC,OAAOD,QAAU3K,EAGjBW,EAAKX,UAAYA,GATV8B,QCgKRQ,KAAKR","file":"slideshow.min.js","sourcesContent":["'use strict'\n# requestAnimationFrame polyfill\n# http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n# http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n# requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n# MIT license\n\ndo (root = window ? this) ->\n  lastTime = 0\n  vendors = ['ms', 'moz', 'webkit', 'o']\n  i = 0\n  while i < vendors.length and not root.requestAnimationFrame\n    vendor = vendors[i++]\n    root.requestAnimationFrame = root[\"#{vendor}RequestAnimationFrame\"]\n    root.cancelAnimationFrame = root[\"#{vendor}CancelAnimationFrame\"] ? root[\"#{vendor}CancelRequestAnimationFrame\"]\n\n\n  unless root.requestAnimationFrame?\n    root.requestAnimationFrame = (callback) ->\n      currTime = new Date().getTime()\n      timeToCall = Math.max 0, 16 - (currTime - lastTime)\n      id = root.setTimeout (-> callback currTime + timeToCall), timeToCall\n      lastTime = currTime + timeToCall\n      id\n\n  unless root.cancelAnimationFrame?\n    root.cancelAnimationFrame = (id) ->\n      clearTimeout id\n\n# end requestAnimationFrame polyfill\n\n# indexOf(array, match) is equivalent to array.indexOf(match)\n\nindexOf = (array, match) ->\n  return unless array?\n  if Array::indexOf?\n    return Array::indexOf.call Array::slice.call(array), match\n  for item, i in array when item is match\n    return i\n  -1\n\n# extend target with properties from object in objects\n\nextend = (target, objects...) ->\n  return unless typeof target is 'object'\n  for object in objects\n    for own prop of object\n      target[prop] = object[prop]\n  target\n\n# shallow clone object\n\nclone = (object) -> extend {}, object\n\n# bind(fn, context) binds context to fn\n\nbind = (fn, context) -> -> fn.apply context, [].slice.call arguments\n\nnow = Date.now ? -> new Date().getTime()\n\nclass Slideshow\n  constructor: (element, options = {}) ->\n    # test if element is a valid html element or maybe\n    # a jQuery object or Backbone View\n    unless element.nodeType is 1\n      if element[0]? then element = element[0] # jQuery\n      if element.el? then element = element.el # Backbone\n    if element.nodeType isnt 1\n      throw new Error 'No valid element provided'\n    @configure options\n    @el = element\n    # and go!\n    init.call @\n\n  configure: (options) ->\n    @options = extend {}, defaults, options\n    if typeof @options.effect is 'string' and effects[@options.effect]?\n      @options.effect = clone effects[@options.effect]\n      @options.effect.conditions ?= effects.default.conditions.concat()\n\n  # private API\n\n  defaults =\n    touchEventsEnabled: true\n    mouseEventsEnabled: true\n    preventDefaultEvents: true\n    animationDuration: 400\n    animationDirection: 'x'\n    effect: 'default'\n\n  effects =\n    default: do ->\n\n      transformCSSProperty = do ->\n        style = document.createElement('div').style\n        return 'transform' if style['transform']?\n        for vendor in ['moz', 'webkit', 'khtml', 'o', 'ms']\n          prefixed = \"#{vendor}Transform\"\n          return prefixed if style[prefixed]?\n        false\n\n      conditions: [\n        progress: .1\n        time: 250\n        durationModifier: .5\n      ,\n        progress: .3\n        time: 500\n      ,\n        progress: .5\n      ]\n      before: (slideState, slideElement) ->\n        slideElement.style.display = 'block'\n        ###\n        slideState  is either -1, 0 or 1\n        if slideState === 0 then this is the current slide and we want to show it, so set translateX(0)\n        if slideState === -1 then this is the previous slide (to the left) so translateX(-100%)\n        if slideState === 1 then this is the next slide (to the right) so translateX(100%)\n        ###\n        X = -slideState * 100\n        if transformCSSProperty\n          slideElement.style[transformCSSProperty] = \"translateX(#{X}%)\"\n        else\n          slideElement.style.left = \"#{X}%\"\n      progress: (slideState, progress, slideElement) ->\n        ###\n        slideState = either 0 or 1\n        0 <= Math.abs(progress) <= 1, but progress can also be negative.\n        progress < 0 indicates movement to the left\n        progress > 0 indicates movement to the right\n\n        if slideState === 0 then this is the current slide and we want it to move away as progress increases:\n        X1 = 100 * p where p = progress\n        if slideState === 1 then this is the target slide and we want it to move in from the left/right as progress increases:\n        X2 = 100 * (-p / |p|) * (|p| - 1) where |p| = Math.abs(progress)\n\n        X = (1 - S) * X1 + S * X2 where S = slideState\n        X is the translateX value that should be set on this slide\n\n        X = (1 - S) * 100 * p + S * 100 * (-p / |p|) * (1 - |p|)\n        X = 100 * p * ( (1 - S) - S * (1 / |p|) * (1 - |p|) )\n        X = 100 * p * ( 1 - S - S * ( (1 / |p|) - 1 ) )\n        X = 100 * p * ( 1 - S + S * (1 - (1 / |p|) ) )\n        X = 100 * p * ( 1 - S + S - (S / |p|) )\n        X = 100 * p * ( 1 - (S / |p|) )\n        ###\n        X = 100 * progress * (1 - slideState / Math.abs progress)\n        if transformCSSProperty\n          slideElement.style[transformCSSProperty] = \"translateX(#{X}%)\"\n        else\n          slideElement.style.left = \"#{X}%\"\n      after: (slideState, slideElement) ->\n        ###\n        slideState is either 0 or 1\n        if slideState === 0 then this is the previously visible slide and it must be hidden\n        if slideState === 1 then this is the currently visible slide and it must be visible\n        ###\n        slideElement.style.display = if slideState > 0 then 'block' else 'none'\n\n  init = ->\n    initSlides.call @\n    initEvents.call @\n\n  initSlides = ->\n    # we don't want the slides to be visible outside their container\n    effectBefore = @options.effect.before ? Function.prototype\n    effectAfter = @options.effect.after ? Function.prototype\n    # el.children may behave weird in IE8\n    @slides = @el.children ? @el.childNodes\n    @current = 0\n    for slide, i in @slides when i isnt @current\n      # call the before and after functions once on all slides, so all slides\n      # are positioned properly\n      if i is @current\n        effectBefore.call @, 0, @slides[@current]\n        effectAfter.call @, 1, @slides[@current]\n      else\n        effectBefore.call @, 1, slide\n        effectAfter.call @, 0, slide\n\n  initEvents = ->\n    @eventStart = bind eventStart, @\n    @eventProgress = bind eventProgress, @\n    @eventEnd = bind eventEnd, @\n    # check for TouchEvent support and if enabled in options\n    if TouchEvent? and @options.touchEventsEnabled\n      @el.addEventListener 'touchstart', @eventStart\n      @el.addEventListener 'touchmove', @eventProgress\n      @el.addEventListener 'touchend', @eventEnd\n    # check for MouseEvent support and if enabled in options\n    if MouseEvent? and @options.mouseEventsEnabled\n      @el.addEventListener 'mousedown', @eventStart\n      @el.addEventListener 'mousemove', @eventProgress\n      @el.addEventListener 'mouseup', @eventEnd\n      @el.addEventListener 'mouseleave', @eventEnd\n      for slide in @slides\n        slide.addEventListener 'mousedown', preventDefault\n        slide.addEventListener 'mousemove', preventDefault\n        slide.addEventListener 'mouseup', preventDefault\n\n  setCurrentSlide = (slide) ->\n    # set @current to slide's index in @slides\n    @current = indexOf @slides, slide\n\n  animateSlides = (currentSlide, targetSlide, {direction, initialProgress, durationMod}, callback) ->\n    # return if an animation is in progress\n    return if @currentAnimation?\n    # call onWillChange\n    unless @currentEvent? and @currentEvent.cancelOnWillChange\n      @options.onWillChange?.call @, currentSlide, targetSlide, (@current + 1) % @slides.length\n    # progress and durationMod are only passed from a touch event\n    progress = initialProgress ? 0\n    durationMod ?= 1\n    # alter the duration of the animation after a touch event\n    duration = Math.max 1, @options.animationDuration * (1 - progress) * durationMod\n    # slides shouldn't be prepared if this is called from a touch event\n    # because this has already happened in touchStart\n    unless @currentEvent?\n      effectBefore = @options.effect.before ? Function.prototype\n      effectBefore.call @, 0, currentSlide\n      effectBefore.call @, (if direction < 0 then 1 else -1), targetSlide\n    # cache the animation state\n    @currentAnimation = {start: now(), currentSlide, targetSlide, direction, duration, progress, callback}\n    # and finally start animating\n    requestAnimationFrame bind nextFrame, @\n\n  nextFrame = (timestamp) ->\n    # immediately call the next requestAnimationFrame\n    id = requestAnimationFrame bind nextFrame, @\n    anim = @currentAnimation\n    {start, progress, duration, direction, currentSlide, targetSlide, callback} = @currentAnimation\n    # calculate the actual progress (fraction of the animationDuration)\n    progress = progress + (now() - start) / duration * (1 - progress)\n    if progress >= 1\n      progress = 1\n      # the animation has ended\n      @currentAnimation = null\n      cancelAnimationFrame id\n      # call the after and callback functions\n      effectAfter = @options.effect.after ? Function.prototype\n      effectAfter.call @, 0, currentSlide\n      effectAfter.call @, 1, targetSlide\n      # set the new currentSlide\n      setCurrentSlide.call @, targetSlide\n      callback?.call @, currentSlide, targetSlide, @current\n      @options.onDidChange?.call @, currentSlide, targetSlide, @current\n      setCurrentSlide.call @, targetSlide\n    # call the progress functions\n    effectProgress = @options.effect.progress ? Function.prototype\n    effectProgress.call @, 0, progress * direction, currentSlide\n    effectProgress.call @, 1, progress * direction, targetSlide\n\n  eventStart = (event) ->\n    if @options.preventDefaultEvents\n      event.preventDefault()\n    # do nothing if an animation or touch event is currently in progress\n    return if @currentAnimation? or @currentEvent?\n    # get the relevant slides\n    currentSlide = @getCurrentSlide()\n    prevSlide = @getPrevSlide()\n    nextSlide = @getNextSlide()\n    # prepare the slides to be animated\n    effectBefore = @options.effect.before ? Function.prototype\n    effectBefore.call @, 0, currentSlide\n    effectBefore.call @, -1, prevSlide\n    effectBefore.call @, 1, nextSlide\n    # cache the touch event state\n    {timeStamp} = event\n    {pageX: startX, pageY: startY} = event.touches?[0] ? event\n    @currentEvent = {currentSlide, prevSlide, nextSlide, timeStamp, startX, startY}\n\n  eventProgress = (event) ->\n    if @options.preventDefaultEvents\n      event.preventDefault()\n    # do nothing if an animation is in progress, or there's no touch event in progress yet (which souldn't happen)\n    return if @currentAnimation or not @currentEvent?\n    {pageX, pageY} = event.touches?[0] ? event\n    # calculate the progress based on the distance touched\n    # progress = switch @options.animationDirection\n    #   when 'x' then (pageX - @currentEvent.startX) / @el.clientWidth\n    #   when 'y' then (pageY - @currentEvent.startY) / @el.clientHeight\n    progress =\n      x: (pageX - @currentEvent.startX) / @el.clientWidth\n      y: (pageY - @currentEvent.startY) / @el.clientHeight\n    progress = switch @options.animationDirection\n      when 'x'\n        if Math.abs(progress.x) > Math.abs(progress.y) then progress.x\n      when 'y'\n        if Math.abs(progress.y) > Math.abs(progress.x) then progress.y\n    @currentEvent.shouldCancel = !progress\n    return unless progress?\n    # get the target slide\n    targetSlide = if progress < 0 then @currentEvent.nextSlide else @currentEvent.prevSlide\n    if targetSlide isnt @currentEvent.targetSlide\n      @currentEvent.cancelOnWillChange = false\n      @currentEvent.targetslide = targetSlide\n    # trigger onWillChange event\n    unless @currentEvent.cancelOnWillChange and progress isnt 0\n      @currentEvent.cancelOnWillChange = true\n      nextIndex = (@current - progress / Math.abs progress) % @slides.length\n      @options.onWillChange?.call @, @currentEvent.currentSlide, targetSlide, (@current - progress / Math.abs progress) % @slides.length\n    @currentEvent.targetSlide = targetSlide\n    # animate the slide\n    requestAnimationFrame =>\n      effectProgress = @options.effect.progress ? Function.prototype\n      effectProgress.call @, 0, progress, @currentEvent.currentSlide\n      effectProgress.call @, 1, progress, targetSlide\n\n  eventEnd = (event) ->\n    if @options.preventDefaultEvents\n      event.preventDefault()\n    # do nothing if an animation is in progress, or there's no touch event in progress yet (which souldn't happen)\n    return if @currentAnimation or not @currentEvent?\n    {timeStamp} = event\n    {pageX, pageY} = event.changedTouches?[0] ? event\n    # calculate the final progress that has been made\n    progress = switch @options.animationDirection\n      when 'x' then (pageX - @currentEvent.startX) / @el.clientWidth\n      when 'y' then (pageY - @currentEvent.startY) / @el.clientHeight\n    if @currentEvent.shouldCancel\n      currentSlide = if progress > 0 then @currentEvent.nextSlide else @currentEvent.prevSlide\n      direction = progress / Math.abs progress\n      initialProgress = 1 - Math.abs progress\n      animateSlides.call @, currentslide, @currentEvent.currentSlide, {direction, initialProgress}\n      @currentEvent = null\n      return\n    if progress is 0\n      @currentEvent = null\n      return\n    # calculate the time passed\n    timePassed = timeStamp - @currentEvent.timeStamp\n    progressAbs = Math.abs progress\n    # check progress and timePassed against the conditions\n    for condition in @options.effect.conditions\n      if progressAbs > condition.progress and timePassed < (condition.time ? Infinity)\n        # one condition passed so set durationMod from that condition\n        durationMod = condition.durationModifier ? 1\n        break\n    # at this point, durationMod is only set if we matched a condition\n    # so slide to the next slide\n    if durationMod?\n      # we matched a condition, so slide away the currentSlide and slide in\n      # the targetSlide. if we slided to the left, the nextSlide will be the\n      # targetSlide, else the prevSlide will be.\n      currentSlide = @currentEvent.currentSlide\n      direction = progress / progressAbs\n      if direction is 1\n        targetSlide = @currentEvent.prevSlide\n      else\n        targetSlide = @currentEvent.nextSlide\n      initialProgress = progressAbs\n    else\n      # we didn't match a condition, so slide the currentSlide back into\n      # position and slide targetSlide (nextSlide or prevSlide, depending on\n      # slide direction) away\n      targetSlide = @currentEvent.currentSlide\n      direction = -progress / progressAbs\n      if direction is 1\n        currentSlide = @currentEvent.nextSlide\n      else\n        currentSlide = @currentEvent.prevSlide\n      initialProgress = 1 - progressAbs\n    # call the animateSlides function with the parameters\n    animateSlides.call @, currentSlide, targetSlide, {direction, initialProgress, durationMod}, =>\n      @currentEvent = null\n\n  preventDefault = (event) ->\n    event.preventDefault()\n\n  # end private API\n\n  # public API\n\n  # get*Slide all return an HTMLElement\n\n  # get the slide at index i\n  # getSlide(-1) === getSlide(slides.length - 1)\n  # and getSlide(slides.length) === getSlide(0)\n  getSlide: (i) ->\n    i = i % @slides.length\n    if i < 0 then i += @slides.length\n    @slides[i]\n\n  # get the currently visible slide\n  getCurrentSlide: -> @slides[@current]\n\n  getCurrentIndex: -> @current\n\n  # get the slide after the currently visible one\n  getNextSlide: -> @getSlide @current + 1\n\n  # get the slide before the currently visible one\n  getPrevSlide: -> @getSlide @current - 1\n\n  # get the first slide\n  getFirstSlide: -> @slides[0]\n\n  # get the last slide\n  getLastSlide: -> @slides[@slides.length - 1]\n\n  # goTo* initiates an animation\n\n  # go to the slide at index i\n  goTo: (i, cb) ->\n    return if i is @current\n    currentSlide = @getCurrentSlide()\n    targetSlide = @getSlide i\n    # slide to left if i < @current, else slide to right\n    direction = if i < @current then 1 else -1\n    animateSlides.call @, currentSlide, targetSlide, {direction}, cb\n\n  # go to the next slide\n  goToNext: (cb) -> @goTo @current + 1, cb\n\n  # go to the previous slide\n  goToPrev: (cb) -> @goTo @current - 1, cb\n\n  # go to first slide\n  goToFirst: (cb) -> @goTo 0, cb\n\n  # go to last slide\n  goToLast: (cb) -> @goTo @slides.length - 1, cb\n\n  # destroy this instance\n  destroy: ->\n    @el.removeEventListener 'touchstart', @eventStart\n    @el.removeEventListener 'touchmove', @eventProgress\n    @el.removeEventListener 'touchend', @eventEnd\n    @el.removeEventListener 'mousedown', @eventStart\n    @el.removeEventListener 'mousemove', @eventProgress\n    @el.removeEventListener 'mouseup', @eventEnd\n    @el.removeEventListener 'mouseleave', @eventEnd\n    for slide in @slides\n      slide.removeEventListener 'mousedown', preventDefault\n      slide.removeEventListener 'mousemove', preventDefault\n      slide.removeEventListener 'mouseup', preventDefault\n    {@el, @slides, @eventStart, @eventProgress, @eventEnd, @options} = {}\n\n  # class methods\n\n  @registerAsJQueryPlugin: (jQuery, methodName = 'Slideshow') ->\n    jQuery.fn[methodName] = (options) -> (new Slideshow container, options for container in @)\n\n  @registerEffect: (name, effect) ->\n    effect.conditions ?= effects.default.conditions.concat()\n    effects[name] ?= effect\n\n# amd, commonjs and browser environment support\ndo (root = this) ->\n  # amd\n  if typeof define is 'function' and define.amd\n    define [], -> Slideshow\n  # commonjs\n  else if typeof exports isnt 'undefined'\n    module.exports = Slideshow\n  # browser\n  else\n    root.Slideshow = Slideshow\n","(function() {\n  'use strict';\n  var Slideshow, bind, clone, extend, indexOf, now, _ref,\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  (function(root) {\n    var i, lastTime, vendor, vendors, _ref;\n    lastTime = 0;\n    vendors = ['ms', 'moz', 'webkit', 'o'];\n    i = 0;\n    while (i < vendors.length && !root.requestAnimationFrame) {\n      vendor = vendors[i++];\n      root.requestAnimationFrame = root[vendor + \"RequestAnimationFrame\"];\n      root.cancelAnimationFrame = (_ref = root[vendor + \"CancelAnimationFrame\"]) != null ? _ref : root[vendor + \"CancelRequestAnimationFrame\"];\n    }\n    if (root.requestAnimationFrame == null) {\n      root.requestAnimationFrame = function(callback) {\n        var currTime, id, timeToCall;\n        currTime = new Date().getTime();\n        timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        id = root.setTimeout((function() {\n          return callback(currTime + timeToCall);\n        }), timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n    if (root.cancelAnimationFrame == null) {\n      return root.cancelAnimationFrame = function(id) {\n        return clearTimeout(id);\n      };\n    }\n  })(typeof window !== \"undefined\" && window !== null ? window : this);\n\n  indexOf = function(array, match) {\n    var i, item, _i, _len;\n    if (array == null) {\n      return;\n    }\n    if (Array.prototype.indexOf != null) {\n      return Array.prototype.indexOf.call(Array.prototype.slice.call(array), match);\n    }\n    for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {\n      item = array[i];\n      if (item === match) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  extend = function() {\n    var object, objects, prop, target, _i, _len;\n    target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (typeof target !== 'object') {\n      return;\n    }\n    for (_i = 0, _len = objects.length; _i < _len; _i++) {\n      object = objects[_i];\n      for (prop in object) {\n        if (!__hasProp.call(object, prop)) continue;\n        target[prop] = object[prop];\n      }\n    }\n    return target;\n  };\n\n  clone = function(object) {\n    return extend({}, object);\n  };\n\n  bind = function(fn, context) {\n    return function() {\n      return fn.apply(context, [].slice.call(arguments));\n    };\n  };\n\n  now = (_ref = Date.now) != null ? _ref : function() {\n    return new Date().getTime();\n  };\n\n  Slideshow = (function() {\n    var animateSlides, defaults, effects, eventEnd, eventProgress, eventStart, init, initEvents, initSlides, nextFrame, preventDefault, setCurrentSlide;\n\n    function Slideshow(element, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (element.nodeType !== 1) {\n        if (element[0] != null) {\n          element = element[0];\n        }\n        if (element.el != null) {\n          element = element.el;\n        }\n      }\n      if (element.nodeType !== 1) {\n        throw new Error('No valid element provided');\n      }\n      this.configure(options);\n      this.el = element;\n      init.call(this);\n    }\n\n    Slideshow.prototype.configure = function(options) {\n      var _base;\n      this.options = extend({}, defaults, options);\n      if (typeof this.options.effect === 'string' && (effects[this.options.effect] != null)) {\n        this.options.effect = clone(effects[this.options.effect]);\n        return (_base = this.options.effect).conditions != null ? _base.conditions : _base.conditions = effects[\"default\"].conditions.concat();\n      }\n    };\n\n    defaults = {\n      touchEventsEnabled: true,\n      mouseEventsEnabled: true,\n      preventDefaultEvents: true,\n      animationDuration: 400,\n      animationDirection: 'x',\n      effect: 'default'\n    };\n\n    effects = {\n      \"default\": (function() {\n        var transformCSSProperty;\n        transformCSSProperty = (function() {\n          var prefixed, style, vendor, _i, _len, _ref1;\n          style = document.createElement('div').style;\n          if (style['transform'] != null) {\n            return 'transform';\n          }\n          _ref1 = ['moz', 'webkit', 'khtml', 'o', 'ms'];\n          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n            vendor = _ref1[_i];\n            prefixed = vendor + \"Transform\";\n            if (style[prefixed] != null) {\n              return prefixed;\n            }\n          }\n          return false;\n        })();\n        return {\n          conditions: [\n            {\n              progress: .1,\n              time: 250,\n              durationModifier: .5\n            }, {\n              progress: .3,\n              time: 500\n            }, {\n              progress: .5\n            }\n          ],\n          before: function(slideState, slideElement) {\n            var X;\n            slideElement.style.display = 'block';\n\n            /*\n            slideState  is either -1, 0 or 1\n            if slideState === 0 then this is the current slide and we want to show it, so set translateX(0)\n            if slideState === -1 then this is the previous slide (to the left) so translateX(-100%)\n            if slideState === 1 then this is the next slide (to the right) so translateX(100%)\n             */\n            X = -slideState * 100;\n            if (transformCSSProperty) {\n              return slideElement.style[transformCSSProperty] = \"translateX(\" + X + \"%)\";\n            } else {\n              return slideElement.style.left = X + \"%\";\n            }\n          },\n          progress: function(slideState, progress, slideElement) {\n\n            /*\n            slideState = either 0 or 1\n            0 <= Math.abs(progress) <= 1, but progress can also be negative.\n            progress < 0 indicates movement to the left\n            progress > 0 indicates movement to the right\n            \n            if slideState === 0 then this is the current slide and we want it to move away as progress increases:\n            X1 = 100 * p where p = progress\n            if slideState === 1 then this is the target slide and we want it to move in from the left/right as progress increases:\n            X2 = 100 * (-p / |p|) * (|p| - 1) where |p| = Math.abs(progress)\n            \n            X = (1 - S) * X1 + S * X2 where S = slideState\n            X is the translateX value that should be set on this slide\n            \n            X = (1 - S) * 100 * p + S * 100 * (-p / |p|) * (1 - |p|)\n            X = 100 * p * ( (1 - S) - S * (1 / |p|) * (1 - |p|) )\n            X = 100 * p * ( 1 - S - S * ( (1 / |p|) - 1 ) )\n            X = 100 * p * ( 1 - S + S * (1 - (1 / |p|) ) )\n            X = 100 * p * ( 1 - S + S - (S / |p|) )\n            X = 100 * p * ( 1 - (S / |p|) )\n             */\n            var X;\n            X = 100 * progress * (1 - slideState / Math.abs(progress));\n            if (transformCSSProperty) {\n              return slideElement.style[transformCSSProperty] = \"translateX(\" + X + \"%)\";\n            } else {\n              return slideElement.style.left = X + \"%\";\n            }\n          },\n          after: function(slideState, slideElement) {\n\n            /*\n            slideState is either 0 or 1\n            if slideState === 0 then this is the previously visible slide and it must be hidden\n            if slideState === 1 then this is the currently visible slide and it must be visible\n             */\n            return slideElement.style.display = slideState > 0 ? 'block' : 'none';\n          }\n        };\n      })()\n    };\n\n    init = function() {\n      initSlides.call(this);\n      return initEvents.call(this);\n    };\n\n    initSlides = function() {\n      var effectAfter, effectBefore, i, slide, _i, _len, _ref1, _ref2, _ref3, _ref4, _results;\n      effectBefore = (_ref1 = this.options.effect.before) != null ? _ref1 : Function.prototype;\n      effectAfter = (_ref2 = this.options.effect.after) != null ? _ref2 : Function.prototype;\n      this.slides = (_ref3 = this.el.children) != null ? _ref3 : this.el.childNodes;\n      this.current = 0;\n      _ref4 = this.slides;\n      _results = [];\n      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {\n        slide = _ref4[i];\n        if (i !== this.current) {\n          if (i === this.current) {\n            effectBefore.call(this, 0, this.slides[this.current]);\n            _results.push(effectAfter.call(this, 1, this.slides[this.current]));\n          } else {\n            effectBefore.call(this, 1, slide);\n            _results.push(effectAfter.call(this, 0, slide));\n          }\n        }\n      }\n      return _results;\n    };\n\n    initEvents = function() {\n      var slide, _i, _len, _ref1, _results;\n      this.eventStart = bind(eventStart, this);\n      this.eventProgress = bind(eventProgress, this);\n      this.eventEnd = bind(eventEnd, this);\n      if ((typeof TouchEvent !== \"undefined\" && TouchEvent !== null) && this.options.touchEventsEnabled) {\n        this.el.addEventListener('touchstart', this.eventStart);\n        this.el.addEventListener('touchmove', this.eventProgress);\n        this.el.addEventListener('touchend', this.eventEnd);\n      }\n      if ((typeof MouseEvent !== \"undefined\" && MouseEvent !== null) && this.options.mouseEventsEnabled) {\n        this.el.addEventListener('mousedown', this.eventStart);\n        this.el.addEventListener('mousemove', this.eventProgress);\n        this.el.addEventListener('mouseup', this.eventEnd);\n        this.el.addEventListener('mouseleave', this.eventEnd);\n        _ref1 = this.slides;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          slide = _ref1[_i];\n          slide.addEventListener('mousedown', preventDefault);\n          slide.addEventListener('mousemove', preventDefault);\n          _results.push(slide.addEventListener('mouseup', preventDefault));\n        }\n        return _results;\n      }\n    };\n\n    setCurrentSlide = function(slide) {\n      return this.current = indexOf(this.slides, slide);\n    };\n\n    animateSlides = function(currentSlide, targetSlide, _arg, callback) {\n      var direction, duration, durationMod, effectBefore, initialProgress, progress, _ref1, _ref2;\n      direction = _arg.direction, initialProgress = _arg.initialProgress, durationMod = _arg.durationMod;\n      if (this.currentAnimation != null) {\n        return;\n      }\n      if (!((this.currentEvent != null) && this.currentEvent.cancelOnWillChange)) {\n        if ((_ref1 = this.options.onWillChange) != null) {\n          _ref1.call(this, currentSlide, targetSlide, (this.current + 1) % this.slides.length);\n        }\n      }\n      progress = initialProgress != null ? initialProgress : 0;\n      if (durationMod == null) {\n        durationMod = 1;\n      }\n      duration = Math.max(1, this.options.animationDuration * (1 - progress) * durationMod);\n      if (this.currentEvent == null) {\n        effectBefore = (_ref2 = this.options.effect.before) != null ? _ref2 : Function.prototype;\n        effectBefore.call(this, 0, currentSlide);\n        effectBefore.call(this, (direction < 0 ? 1 : -1), targetSlide);\n      }\n      this.currentAnimation = {\n        start: now(),\n        currentSlide: currentSlide,\n        targetSlide: targetSlide,\n        direction: direction,\n        duration: duration,\n        progress: progress,\n        callback: callback\n      };\n      return requestAnimationFrame(bind(nextFrame, this));\n    };\n\n    nextFrame = function(timestamp) {\n      var anim, callback, currentSlide, direction, duration, effectAfter, effectProgress, id, progress, start, targetSlide, _ref1, _ref2, _ref3, _ref4;\n      id = requestAnimationFrame(bind(nextFrame, this));\n      anim = this.currentAnimation;\n      _ref1 = this.currentAnimation, start = _ref1.start, progress = _ref1.progress, duration = _ref1.duration, direction = _ref1.direction, currentSlide = _ref1.currentSlide, targetSlide = _ref1.targetSlide, callback = _ref1.callback;\n      progress = progress + (now() - start) / duration * (1 - progress);\n      if (progress >= 1) {\n        progress = 1;\n        this.currentAnimation = null;\n        cancelAnimationFrame(id);\n        effectAfter = (_ref2 = this.options.effect.after) != null ? _ref2 : Function.prototype;\n        effectAfter.call(this, 0, currentSlide);\n        effectAfter.call(this, 1, targetSlide);\n        setCurrentSlide.call(this, targetSlide);\n        if (callback != null) {\n          callback.call(this, currentSlide, targetSlide, this.current);\n        }\n        if ((_ref3 = this.options.onDidChange) != null) {\n          _ref3.call(this, currentSlide, targetSlide, this.current);\n        }\n        setCurrentSlide.call(this, targetSlide);\n      }\n      effectProgress = (_ref4 = this.options.effect.progress) != null ? _ref4 : Function.prototype;\n      effectProgress.call(this, 0, progress * direction, currentSlide);\n      return effectProgress.call(this, 1, progress * direction, targetSlide);\n    };\n\n    eventStart = function(event) {\n      var currentSlide, effectBefore, nextSlide, prevSlide, startX, startY, timeStamp, _ref1, _ref2, _ref3, _ref4;\n      if (this.options.preventDefaultEvents) {\n        event.preventDefault();\n      }\n      if ((this.currentAnimation != null) || (this.currentEvent != null)) {\n        return;\n      }\n      currentSlide = this.getCurrentSlide();\n      prevSlide = this.getPrevSlide();\n      nextSlide = this.getNextSlide();\n      effectBefore = (_ref1 = this.options.effect.before) != null ? _ref1 : Function.prototype;\n      effectBefore.call(this, 0, currentSlide);\n      effectBefore.call(this, -1, prevSlide);\n      effectBefore.call(this, 1, nextSlide);\n      timeStamp = event.timeStamp;\n      _ref4 = (_ref2 = (_ref3 = event.touches) != null ? _ref3[0] : void 0) != null ? _ref2 : event, startX = _ref4.pageX, startY = _ref4.pageY;\n      return this.currentEvent = {\n        currentSlide: currentSlide,\n        prevSlide: prevSlide,\n        nextSlide: nextSlide,\n        timeStamp: timeStamp,\n        startX: startX,\n        startY: startY\n      };\n    };\n\n    eventProgress = function(event) {\n      var nextIndex, pageX, pageY, progress, targetSlide, _ref1, _ref2, _ref3, _ref4;\n      if (this.options.preventDefaultEvents) {\n        event.preventDefault();\n      }\n      if (this.currentAnimation || (this.currentEvent == null)) {\n        return;\n      }\n      _ref3 = (_ref1 = (_ref2 = event.touches) != null ? _ref2[0] : void 0) != null ? _ref1 : event, pageX = _ref3.pageX, pageY = _ref3.pageY;\n      progress = {\n        x: (pageX - this.currentEvent.startX) / this.el.clientWidth,\n        y: (pageY - this.currentEvent.startY) / this.el.clientHeight\n      };\n      progress = (function() {\n        switch (this.options.animationDirection) {\n          case 'x':\n            if (Math.abs(progress.x) > Math.abs(progress.y)) {\n              return progress.x;\n            }\n            break;\n          case 'y':\n            if (Math.abs(progress.y) > Math.abs(progress.x)) {\n              return progress.y;\n            }\n        }\n      }).call(this);\n      this.currentEvent.shouldCancel = !progress;\n      if (progress == null) {\n        return;\n      }\n      targetSlide = progress < 0 ? this.currentEvent.nextSlide : this.currentEvent.prevSlide;\n      if (targetSlide !== this.currentEvent.targetSlide) {\n        this.currentEvent.cancelOnWillChange = false;\n        this.currentEvent.targetslide = targetSlide;\n      }\n      if (!(this.currentEvent.cancelOnWillChange && progress !== 0)) {\n        this.currentEvent.cancelOnWillChange = true;\n        nextIndex = (this.current - progress / Math.abs(progress)) % this.slides.length;\n        if ((_ref4 = this.options.onWillChange) != null) {\n          _ref4.call(this, this.currentEvent.currentSlide, targetSlide, (this.current - progress / Math.abs(progress)) % this.slides.length);\n        }\n      }\n      this.currentEvent.targetSlide = targetSlide;\n      return requestAnimationFrame((function(_this) {\n        return function() {\n          var effectProgress, _ref5;\n          effectProgress = (_ref5 = _this.options.effect.progress) != null ? _ref5 : Function.prototype;\n          effectProgress.call(_this, 0, progress, _this.currentEvent.currentSlide);\n          return effectProgress.call(_this, 1, progress, targetSlide);\n        };\n      })(this));\n    };\n\n    eventEnd = function(event) {\n      var condition, currentSlide, direction, durationMod, initialProgress, pageX, pageY, progress, progressAbs, targetSlide, timePassed, timeStamp, _i, _len, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n      if (this.options.preventDefaultEvents) {\n        event.preventDefault();\n      }\n      if (this.currentAnimation || (this.currentEvent == null)) {\n        return;\n      }\n      timeStamp = event.timeStamp;\n      _ref3 = (_ref1 = (_ref2 = event.changedTouches) != null ? _ref2[0] : void 0) != null ? _ref1 : event, pageX = _ref3.pageX, pageY = _ref3.pageY;\n      progress = (function() {\n        switch (this.options.animationDirection) {\n          case 'x':\n            return (pageX - this.currentEvent.startX) / this.el.clientWidth;\n          case 'y':\n            return (pageY - this.currentEvent.startY) / this.el.clientHeight;\n        }\n      }).call(this);\n      if (this.currentEvent.shouldCancel) {\n        currentSlide = progress > 0 ? this.currentEvent.nextSlide : this.currentEvent.prevSlide;\n        direction = progress / Math.abs(progress);\n        initialProgress = 1 - Math.abs(progress);\n        animateSlides.call(this, currentslide, this.currentEvent.currentSlide, {\n          direction: direction,\n          initialProgress: initialProgress\n        });\n        this.currentEvent = null;\n        return;\n      }\n      if (progress === 0) {\n        this.currentEvent = null;\n        return;\n      }\n      timePassed = timeStamp - this.currentEvent.timeStamp;\n      progressAbs = Math.abs(progress);\n      _ref4 = this.options.effect.conditions;\n      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n        condition = _ref4[_i];\n        if (progressAbs > condition.progress && timePassed < ((_ref5 = condition.time) != null ? _ref5 : Infinity)) {\n          durationMod = (_ref6 = condition.durationModifier) != null ? _ref6 : 1;\n          break;\n        }\n      }\n      if (durationMod != null) {\n        currentSlide = this.currentEvent.currentSlide;\n        direction = progress / progressAbs;\n        if (direction === 1) {\n          targetSlide = this.currentEvent.prevSlide;\n        } else {\n          targetSlide = this.currentEvent.nextSlide;\n        }\n        initialProgress = progressAbs;\n      } else {\n        targetSlide = this.currentEvent.currentSlide;\n        direction = -progress / progressAbs;\n        if (direction === 1) {\n          currentSlide = this.currentEvent.nextSlide;\n        } else {\n          currentSlide = this.currentEvent.prevSlide;\n        }\n        initialProgress = 1 - progressAbs;\n      }\n      return animateSlides.call(this, currentSlide, targetSlide, {\n        direction: direction,\n        initialProgress: initialProgress,\n        durationMod: durationMod\n      }, (function(_this) {\n        return function() {\n          return _this.currentEvent = null;\n        };\n      })(this));\n    };\n\n    preventDefault = function(event) {\n      return event.preventDefault();\n    };\n\n    Slideshow.prototype.getSlide = function(i) {\n      i = i % this.slides.length;\n      if (i < 0) {\n        i += this.slides.length;\n      }\n      return this.slides[i];\n    };\n\n    Slideshow.prototype.getCurrentSlide = function() {\n      return this.slides[this.current];\n    };\n\n    Slideshow.prototype.getCurrentIndex = function() {\n      return this.current;\n    };\n\n    Slideshow.prototype.getNextSlide = function() {\n      return this.getSlide(this.current + 1);\n    };\n\n    Slideshow.prototype.getPrevSlide = function() {\n      return this.getSlide(this.current - 1);\n    };\n\n    Slideshow.prototype.getFirstSlide = function() {\n      return this.slides[0];\n    };\n\n    Slideshow.prototype.getLastSlide = function() {\n      return this.slides[this.slides.length - 1];\n    };\n\n    Slideshow.prototype.goTo = function(i, cb) {\n      var currentSlide, direction, targetSlide;\n      if (i === this.current) {\n        return;\n      }\n      currentSlide = this.getCurrentSlide();\n      targetSlide = this.getSlide(i);\n      direction = i < this.current ? 1 : -1;\n      return animateSlides.call(this, currentSlide, targetSlide, {\n        direction: direction\n      }, cb);\n    };\n\n    Slideshow.prototype.goToNext = function(cb) {\n      return this.goTo(this.current + 1, cb);\n    };\n\n    Slideshow.prototype.goToPrev = function(cb) {\n      return this.goTo(this.current - 1, cb);\n    };\n\n    Slideshow.prototype.goToFirst = function(cb) {\n      return this.goTo(0, cb);\n    };\n\n    Slideshow.prototype.goToLast = function(cb) {\n      return this.goTo(this.slides.length - 1, cb);\n    };\n\n    Slideshow.prototype.destroy = function() {\n      var slide, _i, _len, _ref1, _ref2;\n      this.el.removeEventListener('touchstart', this.eventStart);\n      this.el.removeEventListener('touchmove', this.eventProgress);\n      this.el.removeEventListener('touchend', this.eventEnd);\n      this.el.removeEventListener('mousedown', this.eventStart);\n      this.el.removeEventListener('mousemove', this.eventProgress);\n      this.el.removeEventListener('mouseup', this.eventEnd);\n      this.el.removeEventListener('mouseleave', this.eventEnd);\n      _ref1 = this.slides;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        slide = _ref1[_i];\n        slide.removeEventListener('mousedown', preventDefault);\n        slide.removeEventListener('mousemove', preventDefault);\n        slide.removeEventListener('mouseup', preventDefault);\n      }\n      return _ref2 = {}, this.el = _ref2.el, this.slides = _ref2.slides, this.eventStart = _ref2.eventStart, this.eventProgress = _ref2.eventProgress, this.eventEnd = _ref2.eventEnd, this.options = _ref2.options, _ref2;\n    };\n\n    Slideshow.registerAsJQueryPlugin = function(jQuery, methodName) {\n      if (methodName == null) {\n        methodName = 'Slideshow';\n      }\n      return jQuery.fn[methodName] = function(options) {\n        var container, _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = this.length; _i < _len; _i++) {\n          container = this[_i];\n          _results.push(new Slideshow(container, options));\n        }\n        return _results;\n      };\n    };\n\n    Slideshow.registerEffect = function(name, effect) {\n      if (effect.conditions == null) {\n        effect.conditions = effects[\"default\"].conditions.concat();\n      }\n      return effects[name] != null ? effects[name] : effects[name] = effect;\n    };\n\n    return Slideshow;\n\n  })();\n\n  (function(root) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], function() {\n        return Slideshow;\n      });\n    } else if (typeof exports !== 'undefined') {\n      return module.exports = Slideshow;\n    } else {\n      return root.Slideshow = Slideshow;\n    }\n  })(this);\n\n}).call(this);\n\n//# sourceMappingURL=slideshow.js.map"],"sourceRoot":"/source/"}