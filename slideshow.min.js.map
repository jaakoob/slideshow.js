{"version":3,"sources":["/source/slideshow.coffee","slideshow.js"],"names":["Slideshow","bind","clone","extend","indexOf","now","_ref","__slice","slice","__hasProp","hasOwnProperty","root","i","lastTime","vendor","vendors","length","requestAnimationFrame","cancelAnimationFrame","callback","currTime","id","timeToCall","Date","getTime","Math","max","setTimeout","clearTimeout","window","this","array","match","item","_i","_len","Array","prototype","call","object","objects","prop","target","arguments","fn","context","apply","element","options","nodeType","el","Error","configure","init","animateSlides","defaults","effects","eventEnd","eventProgress","eventStart","initEvents","initSlides","nextFrame","preventDefault","setCurrentSlide","_base","effect","conditions","concat","touchEventsEnabled","mouseEventsEnabled","preventDefaultEvents","animationDuration","animationDirection","default","transformCSSProperty","prefixed","style","_ref1","document","createElement","progress","time","durationModifier","before","slideState","slideElement","X","display","left","abs","after","effectAfter","effectBefore","slide","_ref2","_ref3","_ref4","_results","slides","children","childNodes","current","push","TouchEvent","addEventListener","MouseEvent","currentSlide","targetSlide","_arg","direction","duration","durationMod","initialProgress","currentAnimation","onWillChange","currentEvent","start","anim","effectProgress","onDidChange","event","nextSlide","pageX","pageY","prevSlide","timeStamp","getCurrentSlide","getPrevSlide","getNextSlide","touches","clientWidth","clientHeight","_this","condition","progressAbs","timePassed","_ref5","_ref6","changedTouches","Infinity","getSlide","getCurrentIndex","getFirstSlide","getLastSlide","goTo","cb","goToNext","goToPrev","goToFirst","goToLast","destroy","removeEventListener","registerAsJQueryPlugin","jQuery","methodName","container","registerEffect","name","define","amd","exports","module"],"mappings":"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","file":"slideshow.min.js","sourcesContent":["'use strict'\n# requestAnimationFrame polyfill\n# http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n# http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n# requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n# MIT license\n\ndo (root = window ? this) ->\n  lastTime = 0\n  vendors = ['ms', 'moz', 'webkit', 'o']\n  i = 0\n  while i < vendors.length and not root.requestAnimationFrame\n    vendor = vendors[i++]\n    root.requestAnimationFrame = root[\"#{vendor}RequestAnimationFrame\"]\n    root.cancelAnimationFrame = root[\"#{vendor}CancelAnimationFrame\"] ? root[\"#{vendor}CancelRequestAnimationFrame\"]\n\n\n  unless root.requestAnimationFrame?\n    root.requestAnimationFrame = (callback) ->\n      currTime = new Date().getTime()\n      timeToCall = Math.max 0, 16 - (currTime - lastTime)\n      id = root.setTimeout (-> callback currTime + timeToCall), timeToCall\n      lastTime = currTime + timeToCall\n      id\n\n  unless root.cancelAnimationFrame?\n    root.cancelAnimationFrame = (id) ->\n      clearTimeout id\n\n# end requestAnimationFrame polyfill\n\n# indexOf(array, match) is equivalent to array.indexOf(match)\n\nindexOf = (array, match) ->\n  return unless array?\n  if Array::indexOf?\n    return Array::indexOf.call Array::slice.call(array), match\n  for item, i in array when item is match\n    return i\n  -1\n\n# extend target with properties from object in objects\n\nextend = (target, objects...) ->\n  return unless typeof target is 'object'\n  for object in objects\n    for own prop of object\n      target[prop] = object[prop]\n  target\n\n# shallow clone object\n\nclone = (object) -> extend {}, object\n\n# bind(fn, context) binds context to fn\n\nbind = (fn, context) -> -> fn.apply context, [].slice.call arguments\n\nnow = Date.now ? -> new Date().getTime()\n\nclass Slideshow\n  constructor: (element, options = {}) ->\n    # test if element is a valid html element or maybe\n    # a jQuery object or Backbone View\n    unless element.nodeType is 1\n      if element[0]? then element = element[0] # jQuery\n      if element.el? then element = element.el # Backbone\n    if element.nodeType isnt 1\n      throw new Error 'No valid element provided'\n    @configure options\n    @el = element\n    # and go!\n    init.call @\n\n  configure: (options) ->\n    @options = extend {}, defaults, options\n    if typeof @options.effect is 'string' and effects[@options.effect]?\n      @options.effect = clone effects[@options.effect]\n      @options.effect.conditions ?= effects.default.conditions.concat()\n\n  # private API\n\n  defaults =\n    touchEventsEnabled: true\n    mouseEventsEnabled: true\n    preventDefaultEvents: true\n    animationDuration: 400\n    animationDirection: 'x'\n    effect: 'default'\n\n  effects =\n    default: do ->\n\n      transformCSSProperty = do ->\n        style = document.createElement('div').style\n        return 'transform' if style['transform']?\n        for vendor in ['moz', 'webkit', 'khtml', 'o', 'ms']\n          prefixed = \"#{vendor}Transform\"\n          return prefixed if style[prefixed]?\n        false\n\n      conditions: [\n        progress: .1\n        time: 250\n        durationModifier: .5\n      ,\n        progress: .3\n        time: 500\n      ,\n        progress: .5\n      ]\n      before: (slideState, slideElement) ->\n        slideElement.style.display = 'block'\n        ###\n        slideState  is either -1, 0 or 1\n        if slideState === 0 then this is the current slide and we want to show it, so set translateX(0)\n        if slideState === -1 then this is the previous slide (to the left) so translateX(-100%)\n        if slideState === 1 then this is the next slide (to the right) so translateX(100%)\n        ###\n        X = -slideState * 100\n        if transformCSSProperty\n          slideElement.style[transformCSSProperty] = \"translateX(#{X}%)\"\n        else\n          slideElement.style.left = \"#{X}%\"\n      progress: (slideState, progress, slideElement) ->\n        ###\n        slideState = either 0 or 1\n        0 <= Math.abs(progress) <= 1, but progress can also be negative.\n        progress < 0 indicates movement to the left\n        progress > 0 indicates movement to the right\n\n        if slideState === 0 then this is the current slide and we want it to move away as progress increases:\n        X1 = 100 * p where p = progress\n        if slideState === 1 then this is the target slide and we want it to move in from the left/right as progress increases:\n        X2 = 100 * (-p / |p|) * (|p| - 1) where |p| = Math.abs(progress)\n\n        X = (1 - S) * X1 + S * X2 where S = slideState\n        X is the translateX value that should be set on this slide\n\n        X = (1 - S) * 100 * p + S * 100 * (-p / |p|) * (1 - |p|)\n        X = 100 * p * ( (1 - S) - S * (1 / |p|) * (1 - |p|) )\n        X = 100 * p * ( 1 - S - S * ( (1 / |p|) - 1 ) )\n        X = 100 * p * ( 1 - S + S * (1 - (1 / |p|) ) )\n        X = 100 * p * ( 1 - S + S - (S / |p|) )\n        X = 100 * p * ( 1 - (S / |p|) )\n        ###\n        X = 100 * progress * (1 - slideState / Math.abs progress)\n        if transformCSSProperty\n          slideElement.style[transformCSSProperty] = \"translateX(#{X}%)\"\n        else\n          slideElement.style.left = \"#{X}%\"\n      after: (slideState, slideElement) ->\n        ###\n        slideState is either 0 or 1\n        if slideState === 0 then this is the previously visible slide and it must be hidden\n        if slideState === 1 then this is the currently visible slide and it must be visible\n        ###\n        slideElement.style.display = if slideState > 0 then 'block' else 'none'\n\n  init = ->\n    initSlides.call @\n    initEvents.call @\n\n  initSlides = ->\n    # we don't want the slides to be visible outside their container\n    effectBefore = @options.effect.before ? ->\n    effectAfter = @options.effect.after ? ->\n    # el.children may behave weird in IE8\n    @slides = @el.children ? @el.childNodes\n    @current = 0\n    for slide, i in @slides when i isnt @current\n      # call the before and after functions once on all slides, so all slides\n      # are positioned properly\n      if i is @current\n        effectBefore.call @, 0, @slides[@current]\n        effectAfter.call @, 1, @slides[@current]\n      else\n        effectBefore.call @, 1, slide\n        effectAfter.call @, 0, slide\n\n  initEvents = ->\n    @eventStart = bind eventStart, @\n    @eventProgress = bind eventProgress, @\n    @eventEnd = bind eventEnd, @\n    # check for TouchEvent support and if enabled in options\n    if TouchEvent? and @options.touchEventsEnabled\n      @el.addEventListener 'touchstart', @eventStart\n      @el.addEventListener 'touchmove', @eventProgress\n      @el.addEventListener 'touchend', @eventEnd\n    # check for MouseEvent support and if enabled in options\n    if MouseEvent? and @options.mouseEventsEnabled\n      @el.addEventListener 'mousedown', @eventStart\n      @el.addEventListener 'mousemove', @eventProgress\n      @el.addEventListener 'mouseup', @eventEnd\n      @el.addEventListener 'mouseleave', @eventEnd\n      for slide in @slides\n        slide.addEventListener 'mousedown', preventDefault\n        slide.addEventListener 'mousemove', preventDefault\n        slide.addEventListener 'mouseup', preventDefault\n\n  setCurrentSlide = (slide) ->\n    # set @current to slide's index in @slides\n    @current = indexOf @slides, slide\n\n  animateSlides = (currentSlide, targetSlide, {direction, initialProgress, durationMod}, callback) ->\n    # return if an animation is in progress\n    return if @currentAnimation?\n    # call onWillChange\n    @options.onWillChange?.call @, currentSlide, targetSlide, (@current + 1) % @children.length\n    # progress and durationMod are only passed from a touch event\n    progress = initialProgress ? 0\n    durationMod ?= 1\n    # alter the duration of the animation after a touch event\n    duration = Math.max 1, @options.animationDuration * (1 - progress) * durationMod\n    # slides shouldn't be prepared if this is called from a touch event\n    # because this has already happened in touchStart\n    unless @currentEvent?\n      effectBefore = @options.effect.before ? ->\n      effectBefore.call @, 0, currentSlide\n      effectBefore.call @, (if direction < 0 then 1 else -1), targetSlide\n    # cache the animation state\n    @currentAnimation = {start: now(), currentSlide, targetSlide, direction, duration, progress, callback}\n    # and finally start animating\n    requestAnimationFrame bind nextFrame, @\n\n  nextFrame = (timestamp) ->\n    # immediately call the next requestAnimationFrame\n    id = requestAnimationFrame bind nextFrame, @\n    anim = @currentAnimation\n    {start, progress, duration, direction, currentSlide, targetSlide, callback} = @currentAnimation\n    # calculate the actual progress (fraction of the animationDuration)\n    progress = progress + (now() - start) / duration * (1 - progress)\n    if progress >= 1\n      progress = 1\n      # the animation has ended\n      @currentAnimation = null\n      cancelAnimationFrame id\n      # call the after and callback functions\n      effectAfter = @options.effect.after ? ->\n      effectAfter.call @, 0, currentSlide\n      effectAfter.call @, 1, targetSlide\n      # set the new currentSlide\n      setCurrentSlide.call @, targetSlide\n      callback?.call @, currentSlide, targetSlide, @current\n      @options.onDidChange?.call @, currentSlide, targetSlide, @current\n      setCurrentSlide.call @, targetSlide\n    # call the progress functions\n    effectProgress = @options.effect.progress ? ->\n    effectProgress.call @, 0, progress * direction, currentSlide\n    effectProgress.call @, 1, progress * direction, targetSlide\n\n  eventStart = (event) ->\n    if @options.preventDefaultEvents\n      event.preventDefault()\n    # do nothing if an animation or touch event is currently in progress\n    return if @currentAnimation? or @currentEvent?\n    # get the relevant slides\n    currentSlide = @getCurrentSlide()\n    prevSlide = @getPrevSlide()\n    nextSlide = @getNextSlide()\n    # prepare the slides to be animated\n    effectBefore = @options.effect.before ? ->\n    effectBefore.call @, 0, currentSlide\n    effectBefore.call @, -1, prevSlide\n    effectBefore.call @, 1, nextSlide\n    # cache the touch event state\n    {timeStamp} = event\n    {pageX, pageY} = event.touches?[0] ? event\n    @currentEvent = {currentSlide, prevSlide, nextSlide, timeStamp, pageX, pageY}\n\n  eventProgress = (event) ->\n    if @options.preventDefaultEvents\n      event.preventDefault()\n    # do nothing if an animation is in progress, or there's no touch event in progress yet (which souldn't happen)\n    return if @currentAnimation or not @currentEvent?\n    # calculate the progress based on the distance touched\n    {pageX, pageY} = event.touches?[0] ? event\n    progress = switch @options.animationDirection\n      when 'x' then (pageX - @currentEvent.pageX) / @el.clientWidth\n      when 'y' then (pageY - @currentEvent.pageY) / @el.clientHeight\n    # animate the slide\n    targetSlide = if progress < 0 then @currentEvent.nextSlide else @currentEvent.prevSlide\n    requestAnimationFrame =>\n      effectProgress = @options.effect.progress ? ->\n      effectProgress.call @, 0, progress, @currentEvent.currentSlide\n      effectProgress.call @, 1, progress, targetSlide\n\n  eventEnd = (event) ->\n    if @options.preventDefaultEvents\n      event.preventDefault()\n    # do nothing if an animation is in progress, or there's no touch event in progress yet (which souldn't happen)\n    return if @currentAnimation or not @currentEvent?\n    {timeStamp} = event\n    {pageX, pageY} = event.changedTouches?[0] ? event\n    # calculate the final progress that has been made\n    progress = switch @options.animationDirection\n      when 'x' then (pageX - @currentEvent.pageX) / @el.clientWidth\n      when 'y' then (pageY - @currentEvent.pageY) / @el.clientHeight\n    if progress is 0\n      @currentEvent = null\n      return\n    # calculate the time passed\n    timePassed = timeStamp - @currentEvent.timeStamp\n    progressAbs = Math.abs progress\n    # check progress and timePassed against the conditions\n    for condition in @options.effect.conditions\n      if progressAbs > condition.progress and timePassed < (condition.time ? Infinity)\n        # one condition passed so set durationMod from that condition\n        durationMod = condition.durationModifier ? 1\n        break\n    # at this point, durationMod is only set if we matched a condition\n    # so slide to the next slide\n    if durationMod?\n      # we matched a condition, so slide away the currentSlide and slide in\n      # the targetSlide. if we slided to the left, the nextSlide will be the\n      # targetSlide, else the prevSlide will be.\n      currentSlide = @currentEvent.currentSlide\n      direction = progress / progressAbs\n      if direction is 1\n        targetSlide = @currentEvent.prevSlide\n      else\n        targetSlide = @currentEvent.nextSlide\n      initialProgress = progressAbs\n    else\n      # we didn't match a condition, so slide the currentSlide back into\n      # position and slide targetSlide (nextSlide or prevSlide, depending on\n      # slide direction) away\n      targetSlide = @currentEvent.currentSlide\n      direction = -progress / progressAbs\n      if direction is 1\n        currentSlide = @currentEvent.nextSlide\n      else\n        currentSlide = @currentEvent.prevSlide\n      initialProgress = 1 - progressAbs\n    # call the animateSlides function with the parameters\n    animateSlides.call @, currentSlide, targetSlide, {direction, initialProgress, durationMod}, =>\n      @currentEvent = null\n\n  preventDefault = (event) ->\n    event.preventDefault()\n\n  # end private API\n\n  # public API\n\n  # get*Slide all return an HTMLElement\n\n  # get the slide at index i\n  # getSlide(-1) === getSlide(slides.length - 1)\n  # and getSlide(slides.length) === getSlide(0)\n  getSlide: (i) ->\n    i = i % @slides.length\n    if i < 0 then i += @slides.length\n    @slides[i]\n\n  # get the currently visible slide\n  getCurrentSlide: -> @slides[@current]\n\n  getCurrentIndex: -> @current\n\n  # get the slide after the currently visible one\n  getNextSlide: -> @getSlide @current + 1\n\n  # get the slide before the currently visible one\n  getPrevSlide: -> @getSlide @current - 1\n\n  # get the first slide\n  getFirstSlide: -> @slides[0]\n\n  # get the last slide\n  getLastSlide: -> @slides[@slides.length - 1]\n\n  # goTo* initiates an animation\n\n  # go to the slide at index i\n  goTo: (i, cb) ->\n    return if i is @current\n    currentSlide = @getCurrentSlide()\n    targetSlide = @getSlide i\n    # slide to left if i < @current, else slide to right\n    direction = if i < @current then 1 else -1\n    animateSlides.call @, currentSlide, targetSlide, {direction}, cb\n\n  # go to the next slide\n  goToNext: (cb) -> @goTo @current + 1, cb\n\n  # go to the previous slide\n  goToPrev: (cb) -> @goTo @current - 1, cb\n\n  # go to first slide\n  goToFirst: (cb) -> @goTo 0, cb\n\n  # go to last slide\n  goToLast: (cb) -> @goTo @slides.length - 1, cb\n\n  # destroy this instance\n  destroy: ->\n    @el.removeEventListener 'touchstart', @eventStart\n    @el.removeEventListener 'touchmove', @eventProgress\n    @el.removeEventListener 'touchend', @eventEnd\n    @el.removeEventListener 'mousedown', @eventStart\n    @el.removeEventListener 'mousemove', @eventProgress\n    @el.removeEventListener 'mouseup', @eventEnd\n    @el.removeEventListener 'mouseleave', @eventEnd\n    for slide in @slides\n      slide.removeEventListener 'mousedown', preventDefault\n      slide.removeEventListener 'mousemove', preventDefault\n      slide.removeEventListener 'mouseup', preventDefault\n    {@el, @slides, @eventStart, @eventProgress, @eventEnd, @options} = {}\n\n  # class methods\n\n  @registerAsJQueryPlugin: (jQuery, methodName = 'Slideshow') ->\n    jQuery.fn[methodName] = (options) -> (new Slideshow container, options for container in @)\n\n  @registerEffect: (name, effect) ->\n    effect.conditions ?= effects.default.conditions.concat()\n    effects[name] ?= effect\n\n# amd, commonjs and browser environment support\ndo (root = this) ->\n  # amd\n  if typeof define is 'function' and define.amd\n    define [], -> Slideshow\n  # commonjs\n  else if typeof exports isnt 'undefined'\n    module.exports = Slideshow\n  # browser\n  else\n    root.Slideshow = Slideshow\n","(function() {\n  'use strict';\n  var Slideshow, bind, clone, extend, indexOf, now, _ref,\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  (function(root) {\n    var i, lastTime, vendor, vendors, _ref;\n    lastTime = 0;\n    vendors = ['ms', 'moz', 'webkit', 'o'];\n    i = 0;\n    while (i < vendors.length && !root.requestAnimationFrame) {\n      vendor = vendors[i++];\n      root.requestAnimationFrame = root[vendor + \"RequestAnimationFrame\"];\n      root.cancelAnimationFrame = (_ref = root[vendor + \"CancelAnimationFrame\"]) != null ? _ref : root[vendor + \"CancelRequestAnimationFrame\"];\n    }\n    if (root.requestAnimationFrame == null) {\n      root.requestAnimationFrame = function(callback) {\n        var currTime, id, timeToCall;\n        currTime = new Date().getTime();\n        timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        id = root.setTimeout((function() {\n          return callback(currTime + timeToCall);\n        }), timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n    if (root.cancelAnimationFrame == null) {\n      return root.cancelAnimationFrame = function(id) {\n        return clearTimeout(id);\n      };\n    }\n  })(typeof window !== \"undefined\" && window !== null ? window : this);\n\n  indexOf = function(array, match) {\n    var i, item, _i, _len;\n    if (array == null) {\n      return;\n    }\n    if (Array.prototype.indexOf != null) {\n      return Array.prototype.indexOf.call(Array.prototype.slice.call(array), match);\n    }\n    for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {\n      item = array[i];\n      if (item === match) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  extend = function() {\n    var object, objects, prop, target, _i, _len;\n    target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (typeof target !== 'object') {\n      return;\n    }\n    for (_i = 0, _len = objects.length; _i < _len; _i++) {\n      object = objects[_i];\n      for (prop in object) {\n        if (!__hasProp.call(object, prop)) continue;\n        target[prop] = object[prop];\n      }\n    }\n    return target;\n  };\n\n  clone = function(object) {\n    return extend({}, object);\n  };\n\n  bind = function(fn, context) {\n    return function() {\n      return fn.apply(context, [].slice.call(arguments));\n    };\n  };\n\n  now = (_ref = Date.now) != null ? _ref : function() {\n    return new Date().getTime();\n  };\n\n  Slideshow = (function() {\n    var animateSlides, defaults, effects, eventEnd, eventProgress, eventStart, init, initEvents, initSlides, nextFrame, preventDefault, setCurrentSlide;\n\n    function Slideshow(element, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (element.nodeType !== 1) {\n        if (element[0] != null) {\n          element = element[0];\n        }\n        if (element.el != null) {\n          element = element.el;\n        }\n      }\n      if (element.nodeType !== 1) {\n        throw new Error('No valid element provided');\n      }\n      this.configure(options);\n      this.el = element;\n      init.call(this);\n    }\n\n    Slideshow.prototype.configure = function(options) {\n      var _base;\n      this.options = extend({}, defaults, options);\n      if (typeof this.options.effect === 'string' && (effects[this.options.effect] != null)) {\n        this.options.effect = clone(effects[this.options.effect]);\n        return (_base = this.options.effect).conditions != null ? _base.conditions : _base.conditions = effects[\"default\"].conditions.concat();\n      }\n    };\n\n    defaults = {\n      touchEventsEnabled: true,\n      mouseEventsEnabled: true,\n      preventDefaultEvents: true,\n      animationDuration: 400,\n      animationDirection: 'x',\n      effect: 'default'\n    };\n\n    effects = {\n      \"default\": (function() {\n        var transformCSSProperty;\n        transformCSSProperty = (function() {\n          var prefixed, style, vendor, _i, _len, _ref1;\n          style = document.createElement('div').style;\n          if (style['transform'] != null) {\n            return 'transform';\n          }\n          _ref1 = ['moz', 'webkit', 'khtml', 'o', 'ms'];\n          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n            vendor = _ref1[_i];\n            prefixed = vendor + \"Transform\";\n            if (style[prefixed] != null) {\n              return prefixed;\n            }\n          }\n          return false;\n        })();\n        return {\n          conditions: [\n            {\n              progress: .1,\n              time: 250,\n              durationModifier: .5\n            }, {\n              progress: .3,\n              time: 500\n            }, {\n              progress: .5\n            }\n          ],\n          before: function(slideState, slideElement) {\n            var X;\n            slideElement.style.display = 'block';\n\n            /*\n            slideState  is either -1, 0 or 1\n            if slideState === 0 then this is the current slide and we want to show it, so set translateX(0)\n            if slideState === -1 then this is the previous slide (to the left) so translateX(-100%)\n            if slideState === 1 then this is the next slide (to the right) so translateX(100%)\n             */\n            X = -slideState * 100;\n            if (transformCSSProperty) {\n              return slideElement.style[transformCSSProperty] = \"translateX(\" + X + \"%)\";\n            } else {\n              return slideElement.style.left = X + \"%\";\n            }\n          },\n          progress: function(slideState, progress, slideElement) {\n\n            /*\n            slideState = either 0 or 1\n            0 <= Math.abs(progress) <= 1, but progress can also be negative.\n            progress < 0 indicates movement to the left\n            progress > 0 indicates movement to the right\n            \n            if slideState === 0 then this is the current slide and we want it to move away as progress increases:\n            X1 = 100 * p where p = progress\n            if slideState === 1 then this is the target slide and we want it to move in from the left/right as progress increases:\n            X2 = 100 * (-p / |p|) * (|p| - 1) where |p| = Math.abs(progress)\n            \n            X = (1 - S) * X1 + S * X2 where S = slideState\n            X is the translateX value that should be set on this slide\n            \n            X = (1 - S) * 100 * p + S * 100 * (-p / |p|) * (1 - |p|)\n            X = 100 * p * ( (1 - S) - S * (1 / |p|) * (1 - |p|) )\n            X = 100 * p * ( 1 - S - S * ( (1 / |p|) - 1 ) )\n            X = 100 * p * ( 1 - S + S * (1 - (1 / |p|) ) )\n            X = 100 * p * ( 1 - S + S - (S / |p|) )\n            X = 100 * p * ( 1 - (S / |p|) )\n             */\n            var X;\n            X = 100 * progress * (1 - slideState / Math.abs(progress));\n            if (transformCSSProperty) {\n              return slideElement.style[transformCSSProperty] = \"translateX(\" + X + \"%)\";\n            } else {\n              return slideElement.style.left = X + \"%\";\n            }\n          },\n          after: function(slideState, slideElement) {\n\n            /*\n            slideState is either 0 or 1\n            if slideState === 0 then this is the previously visible slide and it must be hidden\n            if slideState === 1 then this is the currently visible slide and it must be visible\n             */\n            return slideElement.style.display = slideState > 0 ? 'block' : 'none';\n          }\n        };\n      })()\n    };\n\n    init = function() {\n      initSlides.call(this);\n      return initEvents.call(this);\n    };\n\n    initSlides = function() {\n      var effectAfter, effectBefore, i, slide, _i, _len, _ref1, _ref2, _ref3, _ref4, _results;\n      effectBefore = (_ref1 = this.options.effect.before) != null ? _ref1 : function() {};\n      effectAfter = (_ref2 = this.options.effect.after) != null ? _ref2 : function() {};\n      this.slides = (_ref3 = this.el.children) != null ? _ref3 : this.el.childNodes;\n      this.current = 0;\n      _ref4 = this.slides;\n      _results = [];\n      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {\n        slide = _ref4[i];\n        if (i !== this.current) {\n          if (i === this.current) {\n            effectBefore.call(this, 0, this.slides[this.current]);\n            _results.push(effectAfter.call(this, 1, this.slides[this.current]));\n          } else {\n            effectBefore.call(this, 1, slide);\n            _results.push(effectAfter.call(this, 0, slide));\n          }\n        }\n      }\n      return _results;\n    };\n\n    initEvents = function() {\n      var slide, _i, _len, _ref1, _results;\n      this.eventStart = bind(eventStart, this);\n      this.eventProgress = bind(eventProgress, this);\n      this.eventEnd = bind(eventEnd, this);\n      if ((typeof TouchEvent !== \"undefined\" && TouchEvent !== null) && this.options.touchEventsEnabled) {\n        this.el.addEventListener('touchstart', this.eventStart);\n        this.el.addEventListener('touchmove', this.eventProgress);\n        this.el.addEventListener('touchend', this.eventEnd);\n      }\n      if ((typeof MouseEvent !== \"undefined\" && MouseEvent !== null) && this.options.mouseEventsEnabled) {\n        this.el.addEventListener('mousedown', this.eventStart);\n        this.el.addEventListener('mousemove', this.eventProgress);\n        this.el.addEventListener('mouseup', this.eventEnd);\n        this.el.addEventListener('mouseleave', this.eventEnd);\n        _ref1 = this.slides;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          slide = _ref1[_i];\n          slide.addEventListener('mousedown', preventDefault);\n          slide.addEventListener('mousemove', preventDefault);\n          _results.push(slide.addEventListener('mouseup', preventDefault));\n        }\n        return _results;\n      }\n    };\n\n    setCurrentSlide = function(slide) {\n      return this.current = indexOf(this.slides, slide);\n    };\n\n    animateSlides = function(currentSlide, targetSlide, _arg, callback) {\n      var direction, duration, durationMod, effectBefore, initialProgress, progress, _ref1, _ref2;\n      direction = _arg.direction, initialProgress = _arg.initialProgress, durationMod = _arg.durationMod;\n      if (this.currentAnimation != null) {\n        return;\n      }\n      if ((_ref1 = this.options.onWillChange) != null) {\n        _ref1.call(this, currentSlide, targetSlide, (this.current + 1) % this.children.length);\n      }\n      progress = initialProgress != null ? initialProgress : 0;\n      if (durationMod == null) {\n        durationMod = 1;\n      }\n      duration = Math.max(1, this.options.animationDuration * (1 - progress) * durationMod);\n      if (this.currentEvent == null) {\n        effectBefore = (_ref2 = this.options.effect.before) != null ? _ref2 : function() {};\n        effectBefore.call(this, 0, currentSlide);\n        effectBefore.call(this, (direction < 0 ? 1 : -1), targetSlide);\n      }\n      this.currentAnimation = {\n        start: now(),\n        currentSlide: currentSlide,\n        targetSlide: targetSlide,\n        direction: direction,\n        duration: duration,\n        progress: progress,\n        callback: callback\n      };\n      return requestAnimationFrame(bind(nextFrame, this));\n    };\n\n    nextFrame = function(timestamp) {\n      var anim, callback, currentSlide, direction, duration, effectAfter, effectProgress, id, progress, start, targetSlide, _ref1, _ref2, _ref3, _ref4;\n      id = requestAnimationFrame(bind(nextFrame, this));\n      anim = this.currentAnimation;\n      _ref1 = this.currentAnimation, start = _ref1.start, progress = _ref1.progress, duration = _ref1.duration, direction = _ref1.direction, currentSlide = _ref1.currentSlide, targetSlide = _ref1.targetSlide, callback = _ref1.callback;\n      progress = progress + (now() - start) / duration * (1 - progress);\n      if (progress >= 1) {\n        progress = 1;\n        this.currentAnimation = null;\n        cancelAnimationFrame(id);\n        effectAfter = (_ref2 = this.options.effect.after) != null ? _ref2 : function() {};\n        effectAfter.call(this, 0, currentSlide);\n        effectAfter.call(this, 1, targetSlide);\n        setCurrentSlide.call(this, targetSlide);\n        if (callback != null) {\n          callback.call(this, currentSlide, targetSlide, this.current);\n        }\n        if ((_ref3 = this.options.onDidChange) != null) {\n          _ref3.call(this, currentSlide, targetSlide, this.current);\n        }\n        setCurrentSlide.call(this, targetSlide);\n      }\n      effectProgress = (_ref4 = this.options.effect.progress) != null ? _ref4 : function() {};\n      effectProgress.call(this, 0, progress * direction, currentSlide);\n      return effectProgress.call(this, 1, progress * direction, targetSlide);\n    };\n\n    eventStart = function(event) {\n      var currentSlide, effectBefore, nextSlide, pageX, pageY, prevSlide, timeStamp, _ref1, _ref2, _ref3, _ref4;\n      if (this.options.preventDefaultEvents) {\n        event.preventDefault();\n      }\n      if ((this.currentAnimation != null) || (this.currentEvent != null)) {\n        return;\n      }\n      currentSlide = this.getCurrentSlide();\n      prevSlide = this.getPrevSlide();\n      nextSlide = this.getNextSlide();\n      effectBefore = (_ref1 = this.options.effect.before) != null ? _ref1 : function() {};\n      effectBefore.call(this, 0, currentSlide);\n      effectBefore.call(this, -1, prevSlide);\n      effectBefore.call(this, 1, nextSlide);\n      timeStamp = event.timeStamp;\n      _ref4 = (_ref2 = (_ref3 = event.touches) != null ? _ref3[0] : void 0) != null ? _ref2 : event, pageX = _ref4.pageX, pageY = _ref4.pageY;\n      return this.currentEvent = {\n        currentSlide: currentSlide,\n        prevSlide: prevSlide,\n        nextSlide: nextSlide,\n        timeStamp: timeStamp,\n        pageX: pageX,\n        pageY: pageY\n      };\n    };\n\n    eventProgress = function(event) {\n      var pageX, pageY, progress, targetSlide, _ref1, _ref2, _ref3;\n      if (this.options.preventDefaultEvents) {\n        event.preventDefault();\n      }\n      if (this.currentAnimation || (this.currentEvent == null)) {\n        return;\n      }\n      _ref3 = (_ref1 = (_ref2 = event.touches) != null ? _ref2[0] : void 0) != null ? _ref1 : event, pageX = _ref3.pageX, pageY = _ref3.pageY;\n      progress = (function() {\n        switch (this.options.animationDirection) {\n          case 'x':\n            return (pageX - this.currentEvent.pageX) / this.el.clientWidth;\n          case 'y':\n            return (pageY - this.currentEvent.pageY) / this.el.clientHeight;\n        }\n      }).call(this);\n      targetSlide = progress < 0 ? this.currentEvent.nextSlide : this.currentEvent.prevSlide;\n      return requestAnimationFrame((function(_this) {\n        return function() {\n          var effectProgress, _ref4;\n          effectProgress = (_ref4 = _this.options.effect.progress) != null ? _ref4 : function() {};\n          effectProgress.call(_this, 0, progress, _this.currentEvent.currentSlide);\n          return effectProgress.call(_this, 1, progress, targetSlide);\n        };\n      })(this));\n    };\n\n    eventEnd = function(event) {\n      var condition, currentSlide, direction, durationMod, initialProgress, pageX, pageY, progress, progressAbs, targetSlide, timePassed, timeStamp, _i, _len, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n      if (this.options.preventDefaultEvents) {\n        event.preventDefault();\n      }\n      if (this.currentAnimation || (this.currentEvent == null)) {\n        return;\n      }\n      timeStamp = event.timeStamp;\n      _ref3 = (_ref1 = (_ref2 = event.changedTouches) != null ? _ref2[0] : void 0) != null ? _ref1 : event, pageX = _ref3.pageX, pageY = _ref3.pageY;\n      progress = (function() {\n        switch (this.options.animationDirection) {\n          case 'x':\n            return (pageX - this.currentEvent.pageX) / this.el.clientWidth;\n          case 'y':\n            return (pageY - this.currentEvent.pageY) / this.el.clientHeight;\n        }\n      }).call(this);\n      if (progress === 0) {\n        this.currentEvent = null;\n        return;\n      }\n      timePassed = timeStamp - this.currentEvent.timeStamp;\n      progressAbs = Math.abs(progress);\n      _ref4 = this.options.effect.conditions;\n      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n        condition = _ref4[_i];\n        if (progressAbs > condition.progress && timePassed < ((_ref5 = condition.time) != null ? _ref5 : Infinity)) {\n          durationMod = (_ref6 = condition.durationModifier) != null ? _ref6 : 1;\n          break;\n        }\n      }\n      if (durationMod != null) {\n        currentSlide = this.currentEvent.currentSlide;\n        direction = progress / progressAbs;\n        if (direction === 1) {\n          targetSlide = this.currentEvent.prevSlide;\n        } else {\n          targetSlide = this.currentEvent.nextSlide;\n        }\n        initialProgress = progressAbs;\n      } else {\n        targetSlide = this.currentEvent.currentSlide;\n        direction = -progress / progressAbs;\n        if (direction === 1) {\n          currentSlide = this.currentEvent.nextSlide;\n        } else {\n          currentSlide = this.currentEvent.prevSlide;\n        }\n        initialProgress = 1 - progressAbs;\n      }\n      return animateSlides.call(this, currentSlide, targetSlide, {\n        direction: direction,\n        initialProgress: initialProgress,\n        durationMod: durationMod\n      }, (function(_this) {\n        return function() {\n          return _this.currentEvent = null;\n        };\n      })(this));\n    };\n\n    preventDefault = function(event) {\n      return event.preventDefault();\n    };\n\n    Slideshow.prototype.getSlide = function(i) {\n      i = i % this.slides.length;\n      if (i < 0) {\n        i += this.slides.length;\n      }\n      return this.slides[i];\n    };\n\n    Slideshow.prototype.getCurrentSlide = function() {\n      return this.slides[this.current];\n    };\n\n    Slideshow.prototype.getCurrentIndex = function() {\n      return this.current;\n    };\n\n    Slideshow.prototype.getNextSlide = function() {\n      return this.getSlide(this.current + 1);\n    };\n\n    Slideshow.prototype.getPrevSlide = function() {\n      return this.getSlide(this.current - 1);\n    };\n\n    Slideshow.prototype.getFirstSlide = function() {\n      return this.slides[0];\n    };\n\n    Slideshow.prototype.getLastSlide = function() {\n      return this.slides[this.slides.length - 1];\n    };\n\n    Slideshow.prototype.goTo = function(i, cb) {\n      var currentSlide, direction, targetSlide;\n      if (i === this.current) {\n        return;\n      }\n      currentSlide = this.getCurrentSlide();\n      targetSlide = this.getSlide(i);\n      direction = i < this.current ? 1 : -1;\n      return animateSlides.call(this, currentSlide, targetSlide, {\n        direction: direction\n      }, cb);\n    };\n\n    Slideshow.prototype.goToNext = function(cb) {\n      return this.goTo(this.current + 1, cb);\n    };\n\n    Slideshow.prototype.goToPrev = function(cb) {\n      return this.goTo(this.current - 1, cb);\n    };\n\n    Slideshow.prototype.goToFirst = function(cb) {\n      return this.goTo(0, cb);\n    };\n\n    Slideshow.prototype.goToLast = function(cb) {\n      return this.goTo(this.slides.length - 1, cb);\n    };\n\n    Slideshow.prototype.destroy = function() {\n      var slide, _i, _len, _ref1, _ref2;\n      this.el.removeEventListener('touchstart', this.eventStart);\n      this.el.removeEventListener('touchmove', this.eventProgress);\n      this.el.removeEventListener('touchend', this.eventEnd);\n      this.el.removeEventListener('mousedown', this.eventStart);\n      this.el.removeEventListener('mousemove', this.eventProgress);\n      this.el.removeEventListener('mouseup', this.eventEnd);\n      this.el.removeEventListener('mouseleave', this.eventEnd);\n      _ref1 = this.slides;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        slide = _ref1[_i];\n        slide.removeEventListener('mousedown', preventDefault);\n        slide.removeEventListener('mousemove', preventDefault);\n        slide.removeEventListener('mouseup', preventDefault);\n      }\n      return _ref2 = {}, this.el = _ref2.el, this.slides = _ref2.slides, this.eventStart = _ref2.eventStart, this.eventProgress = _ref2.eventProgress, this.eventEnd = _ref2.eventEnd, this.options = _ref2.options, _ref2;\n    };\n\n    Slideshow.registerAsJQueryPlugin = function(jQuery, methodName) {\n      if (methodName == null) {\n        methodName = 'Slideshow';\n      }\n      return jQuery.fn[methodName] = function(options) {\n        var container, _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = this.length; _i < _len; _i++) {\n          container = this[_i];\n          _results.push(new Slideshow(container, options));\n        }\n        return _results;\n      };\n    };\n\n    Slideshow.registerEffect = function(name, effect) {\n      if (effect.conditions == null) {\n        effect.conditions = effects[\"default\"].conditions.concat();\n      }\n      return effects[name] != null ? effects[name] : effects[name] = effect;\n    };\n\n    return Slideshow;\n\n  })();\n\n  (function(root) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], function() {\n        return Slideshow;\n      });\n    } else if (typeof exports !== 'undefined') {\n      return module.exports = Slideshow;\n    } else {\n      return root.Slideshow = Slideshow;\n    }\n  })(this);\n\n}).call(this);\n\n//# sourceMappingURL=slideshow.js.map"],"sourceRoot":"/source/"}