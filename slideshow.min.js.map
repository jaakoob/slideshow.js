{"version":3,"sources":["/source/slideshow.coffee","slideshow.js"],"names":["Slideshow","bind","clone","extend","indexOf","now","ref","slice","hasProp","hasOwnProperty","modulo","a","b","root","i","lastTime","vendor","vendors","length","requestAnimationFrame","cancelAnimationFrame","callback","currTime","id","timeToCall","Date","getTime","Math","max","setTimeout","clearTimeout","window","this","array","match","item","j","len","Array","prototype","call","object","objects","prop","target","arguments","fn","context","apply","element","options","nodeType","el","Error","configure","init","animateSlides","defaults","effects","eventEnd","eventProgress","eventStart","initEvents","initSlides","nextFrame","preventDefault","setCurrentSlide","base","effect","conditions","concat","touchEventsEnabled","mouseEventsEnabled","swipeThreshold","animationDuration","animationDirection","default","transformCSSProperty","prefixed","ref1","style","document","createElement","progress","time","durationModifier","before","slideState","slideElement","X","display","left","abs","after","effectAfter","effectBefore","ref2","ref3","ref4","results","slide","Function","slides","children","childNodes","current","push","TouchEvent","addEventListener","MouseEvent","currentSlide","targetSlide","arg","direction","duration","durationMod","initialProgress","currentAnimation","currentEvent","cancelOnWillChange","onWillChange","start","timestamp","anim","effectProgress","onDidChange","event","nextSlide","prevSlide","startX","startY","timeStamp","getCurrentSlide","getPrevSlide","getNextSlide","touches","pageX","pageY","nextIndex","x","clientWidth","y","clientHeight","shouldCancel","_this","ref5","condition","progressAbs","ref6","timePassed","changedTouches","Infinity","getSlide","getCurrentIndex","getFirstSlide","getLastSlide","goTo","cb","goToNext","goToPrev","goToFirst","goToLast","destroy","removeEventListener","registerAsJQueryPlugin","jQuery","methodName","container","registerEffect","name","define","amd","exports","module"],"mappings":"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","file":"slideshow.min.js","sourcesContent":["'use strict'\n# requestAnimationFrame polyfill\n# http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n# http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n# requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n# MIT license\n\ndo (root = window ? this) ->\n  lastTime = 0\n  vendors = ['ms', 'moz', 'webkit', 'o']\n  i = 0\n  while i < vendors.length and not root.requestAnimationFrame\n    vendor = vendors[i++]\n    root.requestAnimationFrame = root[\"#{vendor}RequestAnimationFrame\"]\n    root.cancelAnimationFrame = root[\"#{vendor}CancelAnimationFrame\"] ? root[\"#{vendor}CancelRequestAnimationFrame\"]\n\n\n  unless root.requestAnimationFrame?\n    root.requestAnimationFrame = (callback) ->\n      currTime = new Date().getTime()\n      timeToCall = Math.max 0, 16 - (currTime - lastTime)\n      id = root.setTimeout (-> callback currTime + timeToCall), timeToCall\n      lastTime = currTime + timeToCall\n      id\n\n  unless root.cancelAnimationFrame?\n    root.cancelAnimationFrame = (id) ->\n      clearTimeout id\n\n# end requestAnimationFrame polyfill\n\n# indexOf(array, match) is equivalent to array.indexOf(match)\n\nindexOf = (array, match) ->\n  return unless array?\n  if Array::indexOf?\n    return Array::indexOf.call Array::slice.call(array), match\n  for item, i in array when item is match\n    return i\n  -1\n\n# extend target with properties from object in objects\n\nextend = (target, objects...) ->\n  return unless typeof target is 'object'\n  for object in objects\n    for own prop of object\n      target[prop] = object[prop]\n  target\n\n# shallow clone object\n\nclone = (object) -> extend {}, object\n\n# bind(fn, context) binds context to fn\n\nbind = (fn, context) -> -> fn.apply context, [].slice.call arguments\n\nnow = Date.now ? -> new Date().getTime()\n\nclass Slideshow\n  constructor: (element, options = {}) ->\n    # test if element is a valid html element or maybe\n    # a jQuery object or Backbone View\n    unless element.nodeType is 1\n      if element[0]? then element = element[0] # jQuery\n      if element.el? then element = element.el # Backbone\n    if element.nodeType isnt 1\n      throw new Error 'No valid element provided'\n    @configure options\n    @el = element\n    # and go!\n    init.call @\n\n  configure: (options) ->\n    @options = extend {}, defaults, options\n    if typeof @options.effect is 'string' and effects[@options.effect]?\n      @options.effect = clone effects[@options.effect]\n      @options.effect.conditions ?= effects.default.conditions.concat()\n\n  # private API\n\n  defaults =\n    touchEventsEnabled: true\n    mouseEventsEnabled: true\n    swipeThreshold: 0\n    animationDuration: 400\n    animationDirection: 'x'\n    effect: 'default'\n\n  effects =\n    default: do ->\n\n      transformCSSProperty = do ->\n        style = document.createElement('div').style\n        return 'transform' if style['transform']?\n        for vendor in ['moz', 'webkit', 'khtml', 'o', 'ms']\n          prefixed = \"#{vendor}Transform\"\n          return prefixed if style[prefixed]?\n        false\n\n      conditions: [\n        progress: .1\n        time: 250\n        durationModifier: .5\n      ,\n        progress: .3\n        time: 500\n      ,\n        progress: .5\n      ]\n      before: (slideState, slideElement) ->\n        slideElement.style.display = 'block'\n        ###\n        slideState  is either -1, 0 or 1\n        if slideState === 0 then this is the current slide and we want to show it, so set translateX(0)\n        if slideState === -1 then this is the previous slide (to the left) so translateX(-100%)\n        if slideState === 1 then this is the next slide (to the right) so translateX(100%)\n        ###\n        X = -slideState * 100\n        if transformCSSProperty\n          slideElement.style[transformCSSProperty] = \"translateX(#{X}%)\"\n        else\n          slideElement.style.left = \"#{X}%\"\n      progress: (slideState, progress, slideElement) ->\n        ###\n        slideState = either 0 or 1\n        0 <= Math.abs(progress) <= 1, but progress can also be negative.\n        progress < 0 indicates movement to the left\n        progress > 0 indicates movement to the right\n\n        if slideState === 0 then this is the current slide and we want it to move away as progress increases:\n        X1 = 100 * p where p = progress\n        if slideState === 1 then this is the target slide and we want it to move in from the left/right as progress increases:\n        X2 = 100 * (-p / |p|) * (|p| - 1) where |p| = Math.abs(progress)\n\n        X = (1 - S) * X1 + S * X2 where S = slideState\n        X is the translateX value that should be set on this slide\n\n        X = (1 - S) * 100 * p + S * 100 * (-p / |p|) * (1 - |p|)\n        X = 100 * p * ( (1 - S) - S * (1 / |p|) * (1 - |p|) )\n        X = 100 * p * ( 1 - S - S * ( (1 / |p|) - 1 ) )\n        X = 100 * p * ( 1 - S + S * (1 - (1 / |p|) ) )\n        X = 100 * p * ( 1 - S + S - (S / |p|) )\n        X = 100 * p * ( 1 - (S / |p|) )\n        ###\n        X = 100 * progress * (1 - slideState / Math.abs progress)\n        if transformCSSProperty\n          slideElement.style[transformCSSProperty] = \"translateX(#{X}%)\"\n        else\n          slideElement.style.left = \"#{X}%\"\n      after: (slideState, slideElement) ->\n        ###\n        slideState is either 0 or 1\n        if slideState === 0 then this is the previously visible slide and it must be hidden\n        if slideState === 1 then this is the currently visible slide and it must be visible\n        ###\n        slideElement.style.display = if slideState > 0 then 'block' else 'none'\n\n  init = ->\n    initSlides.call @\n    initEvents.call @\n\n  initSlides = ->\n    # we don't want the slides to be visible outside their container\n    effectBefore = @options.effect.before ? Function.prototype\n    effectAfter = @options.effect.after ? Function.prototype\n    # el.children may behave weird in IE8\n    @slides = @el.children ? @el.childNodes\n    @current = 0\n    for slide, i in @slides when i isnt @current\n      # call the before and after functions once on all slides, so all slides\n      # are positioned properly\n      if i is @current\n        effectBefore.call @, 0, @slides[@current]\n        effectAfter.call @, 1, @slides[@current]\n      else\n        effectBefore.call @, 1, slide\n        effectAfter.call @, 0, slide\n\n  initEvents = ->\n    @eventStart = bind eventStart, @\n    @eventProgress = bind eventProgress, @\n    @eventEnd = bind eventEnd, @\n    # check for TouchEvent support and if enabled in options\n    if TouchEvent? and @options.touchEventsEnabled\n      @el.addEventListener 'touchstart', @eventStart\n      @el.addEventListener 'touchmove', @eventProgress\n      @el.addEventListener 'touchend', @eventEnd\n    # check for MouseEvent support and if enabled in options\n    if MouseEvent? and @options.mouseEventsEnabled\n      @el.addEventListener 'mousedown', @eventStart\n      @el.addEventListener 'mousemove', @eventProgress\n      @el.addEventListener 'mouseup', @eventEnd\n      @el.addEventListener 'mouseleave', @eventEnd\n      for slide in @slides\n        slide.addEventListener 'mousedown', preventDefault\n        slide.addEventListener 'mousemove', preventDefault\n        slide.addEventListener 'mouseup', preventDefault\n\n  setCurrentSlide = (slide) ->\n    # set @current to slide's index in @slides\n    @current = indexOf @slides, slide\n\n  animateSlides = (currentSlide, targetSlide, {direction, initialProgress, durationMod}, callback) ->\n    # return if an animation is in progress\n    return if @currentAnimation?\n    # call onWillChange\n    unless @currentEvent? and @currentEvent.cancelOnWillChange\n      @options.onWillChange?.call @, currentSlide, targetSlide, (@current - direction / Math.abs(direction)) %% @slides.length\n    # progress and durationMod are only passed from a touch event\n    progress = initialProgress ? 0\n    durationMod ?= 1\n    # alter the duration of the animation after a touch event\n    duration = Math.max 1, @options.animationDuration * (1 - progress) * durationMod\n    # slides shouldn't be prepared if this is called from a touch event\n    # because this has already happened in touchStart\n    unless @currentEvent?\n      effectBefore = @options.effect.before ? Function.prototype\n      effectBefore.call @, 0, currentSlide\n      effectBefore.call @, (if direction < 0 then 1 else -1), targetSlide\n    # cache the animation state\n    @currentAnimation = {start: now(), currentSlide, targetSlide, direction, duration, progress, callback}\n    # and finally start animating\n    requestAnimationFrame bind nextFrame, @\n\n  nextFrame = (timestamp) ->\n    # immediately call the next requestAnimationFrame\n    id = requestAnimationFrame bind nextFrame, @\n    anim = @currentAnimation\n    {start, progress, duration, direction, currentSlide, targetSlide, callback} = @currentAnimation\n    # calculate the actual progress (fraction of the animationDuration)\n    progress = progress + (now() - start) / duration * (1 - progress)\n    if progress >= 1\n      progress = 1\n      # the animation has ended\n      @currentAnimation = null\n      cancelAnimationFrame id\n      # call the after and callback functions\n      effectAfter = @options.effect.after ? Function.prototype\n      effectAfter.call @, 0, currentSlide\n      effectAfter.call @, 1, targetSlide\n      # set the new currentSlide\n      setCurrentSlide.call @, targetSlide\n      if typeof callback == 'function'\n        callback.call @, currentSlide, targetSlide, @current\n      @options.onDidChange?.call @, currentSlide, targetSlide, @current\n      setCurrentSlide.call @, targetSlide\n    # call the progress functions\n    effectProgress = @options.effect.progress ? Function.prototype\n    effectProgress.call @, 0, progress * direction, currentSlide\n    effectProgress.call @, 1, progress * direction, targetSlide\n\n  eventStart = (event) ->\n    # do nothing if an animation or touch event is currently in progress\n    return if @currentAnimation? or @currentEvent?\n    # get the relevant slides\n    currentSlide = @getCurrentSlide()\n    prevSlide = @getPrevSlide()\n    nextSlide = @getNextSlide()\n    # prepare the slides to be animated\n    effectBefore = @options.effect.before ? Function.prototype\n    effectBefore.call @, 0, currentSlide\n    effectBefore.call @, -1, prevSlide\n    effectBefore.call @, 1, nextSlide\n    # cache the touch event state\n    {timeStamp} = event\n    {pageX: startX, pageY: startY} = event.touches?[0] ? event\n    @currentEvent = {currentSlide, prevSlide, nextSlide, timeStamp, startX, startY}\n\n  eventProgress = (event) ->\n    # do nothing if an animation is in progress, or there's no touch event in progress yet (which souldn't happen)\n    return if @currentAnimation or not @currentEvent?\n    {pageX, pageY} = event.touches?[0] ? event\n    # calculate the progress based on the distance touched\n    # progress = switch @options.animationDirection\n    #   when 'x' then (pageX - @currentEvent.startX) / @el.clientWidth\n    #   when 'y' then (pageY - @currentEvent.startY) / @el.clientHeight\n    progress =\n      x: (pageX - @currentEvent.startX) / @el.clientWidth\n      y: (pageY - @currentEvent.startY) / @el.clientHeight\n    progress = switch @options.animationDirection\n      when 'x'\n        if Math.abs(progress.x) > Math.abs(progress.y) then progress.x\n      when 'y'\n        if Math.abs(progress.y) > Math.abs(progress.x) then progress.y\n    @currentEvent.shouldCancel = !progress\n    return unless progress?\n    # get the target slide\n    targetSlide = if progress < 0 then @currentEvent.nextSlide else @currentEvent.prevSlide\n    if targetSlide isnt @currentEvent.targetSlide\n      @currentEvent.cancelOnWillChange = false\n      @currentEvent.targetSlide = targetSlide\n    # trigger onWillChange event\n    unless @currentEvent.cancelOnWillChange and progress isnt 0\n      @currentEvent.cancelOnWillChange = true\n      nextIndex = (@current - progress / Math.abs progress) %% @slides.length\n      @options.onWillChange?.call @, @currentEvent.currentSlide, targetSlide, nextIndex\n    @currentEvent.targetSlide = targetSlide\n    # animate the slide\n    requestAnimationFrame =>\n      effectProgress = @options.effect.progress ? Function.prototype\n      effectProgress.call @, 0, progress, @currentEvent.currentSlide\n      effectProgress.call @, 1, progress, targetSlide\n\n  eventEnd = (event) ->\n    # do nothing if an animation is in progress, or there's no touch event in progress yet (which souldn't happen)\n    return if @currentAnimation or not @currentEvent?\n    {timeStamp} = event\n    {pageX, pageY} = event.changedTouches?[0] ? event\n    # calculate the final progress that has been made\n    progress = switch @options.animationDirection\n      when 'x' then (pageX - @currentEvent.startX) / @el.clientWidth\n      when 'y' then (pageY - @currentEvent.startY) / @el.clientHeight\n    if @currentEvent.shouldCancel\n      currentSlide = if progress > 0 then @currentEvent.nextSlide else @currentEvent.prevSlide\n      direction = progress / Math.abs progress\n      initialProgress = 1 - Math.abs progress\n      animateSlides.call @, currentSlide, @currentEvent.currentSlide, {direction, initialProgress}\n      @currentEvent = null\n      return\n    if progress is 0\n      @currentEvent = null\n      return\n    # calculate the time passed\n    timePassed = timeStamp - @currentEvent.timeStamp\n    progressAbs = Math.abs progress\n    # check progress and timePassed against the conditions\n    for condition in @options.effect.conditions\n      if progressAbs > condition.progress and timePassed < (condition.time ? Infinity)\n        # one condition passed so set durationMod from that condition\n        durationMod = condition.durationModifier ? 1\n        break\n    # at this point, durationMod is only set if we matched a condition\n    # so slide to the next slide\n    if durationMod?\n      # we matched a condition, so slide away the currentSlide and slide in\n      # the targetSlide. if we slided to the left, the nextSlide will be the\n      # targetSlide, else the prevSlide will be.\n      currentSlide = @currentEvent.currentSlide\n      direction = progress / progressAbs\n      if direction is 1\n        targetSlide = @currentEvent.prevSlide\n      else\n        targetSlide = @currentEvent.nextSlide\n      initialProgress = progressAbs\n    else\n      # we didn't match a condition, so slide the currentSlide back into\n      # position and slide targetSlide (nextSlide or prevSlide, depending on\n      # slide direction) away\n      targetSlide = @currentEvent.currentSlide\n      direction = -progress / progressAbs\n      if direction is 1\n        currentSlide = @currentEvent.nextSlide\n      else\n        currentSlide = @currentEvent.prevSlide\n      initialProgress = 1 - progressAbs\n    # call the animateSlides function with the parameters\n    animateSlides.call @, currentSlide, targetSlide, {direction, initialProgress, durationMod}, =>\n      @currentEvent = null\n\n  preventDefault = (event) ->\n    event.preventDefault()\n\n  # end private API\n\n  # public API\n\n  # get*Slide all return an HTMLElement\n\n  # get the slide at index i\n  # getSlide(-1) === getSlide(slides.length - 1)\n  # and getSlide(slides.length) === getSlide(0)\n  getSlide: (i) ->\n    @slides[i %% @slides.length]\n\n  # get the currently visible slide\n  getCurrentSlide: -> @slides[@current]\n\n  getCurrentIndex: -> @current\n\n  # get the slide after the currently visible one\n  getNextSlide: -> @getSlide @current + 1\n\n  # get the slide before the currently visible one\n  getPrevSlide: -> @getSlide @current - 1\n\n  # get the first slide\n  getFirstSlide: -> @slides[0]\n\n  # get the last slide\n  getLastSlide: -> @slides[@slides.length - 1]\n\n  # goTo* initiates an animation\n\n  # go to the slide at index i\n  goTo: (i, cb) ->\n    return if i is @current\n    currentSlide = @getCurrentSlide()\n    targetSlide = @getSlide i\n    # slide to left if i < @current, else slide to right\n    direction = if i < @current then 1 else -1\n    animateSlides.call @, currentSlide, targetSlide, {direction}, cb\n\n  # go to the next slide\n  goToNext: (cb) -> @goTo @current + 1, cb\n\n  # go to the previous slide\n  goToPrev: (cb) -> @goTo @current - 1, cb\n\n  # go to first slide\n  goToFirst: (cb) -> @goTo 0, cb\n\n  # go to last slide\n  goToLast: (cb) -> @goTo @slides.length - 1, cb\n\n  # destroy this instance\n  destroy: ->\n    @el.removeEventListener 'touchstart', @eventStart\n    @el.removeEventListener 'touchmove', @eventProgress\n    @el.removeEventListener 'touchend', @eventEnd\n    @el.removeEventListener 'mousedown', @eventStart\n    @el.removeEventListener 'mousemove', @eventProgress\n    @el.removeEventListener 'mouseup', @eventEnd\n    @el.removeEventListener 'mouseleave', @eventEnd\n    for slide in @slides\n      slide.removeEventListener 'mousedown', preventDefault\n      slide.removeEventListener 'mousemove', preventDefault\n      slide.removeEventListener 'mouseup', preventDefault\n    {@el, @slides, @eventStart, @eventProgress, @eventEnd, @options} = {}\n\n  # class methods\n\n  @registerAsJQueryPlugin: (jQuery, methodName = 'Slideshow') ->\n    jQuery.fn[methodName] = (options) -> (new Slideshow container, options for container in @)\n\n  @registerEffect: (name, effect) ->\n    effect.conditions ?= effects.default.conditions.concat()\n    effects[name] ?= effect\n\n# amd, commonjs and browser environment support\ndo (root = this) ->\n  # amd\n  if typeof define is 'function' and define.amd\n    define [], -> Slideshow\n  # commonjs\n  else if typeof exports isnt 'undefined'\n    module.exports = Slideshow\n  # browser\n  else\n    root.Slideshow = Slideshow\n","(function() {\n  'use strict';\n  var Slideshow, bind, clone, extend, indexOf, now, ref,\n    slice = [].slice,\n    hasProp = {}.hasOwnProperty,\n    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n  (function(root) {\n    var i, lastTime, ref, vendor, vendors;\n    lastTime = 0;\n    vendors = ['ms', 'moz', 'webkit', 'o'];\n    i = 0;\n    while (i < vendors.length && !root.requestAnimationFrame) {\n      vendor = vendors[i++];\n      root.requestAnimationFrame = root[vendor + \"RequestAnimationFrame\"];\n      root.cancelAnimationFrame = (ref = root[vendor + \"CancelAnimationFrame\"]) != null ? ref : root[vendor + \"CancelRequestAnimationFrame\"];\n    }\n    if (root.requestAnimationFrame == null) {\n      root.requestAnimationFrame = function(callback) {\n        var currTime, id, timeToCall;\n        currTime = new Date().getTime();\n        timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        id = root.setTimeout((function() {\n          return callback(currTime + timeToCall);\n        }), timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n    if (root.cancelAnimationFrame == null) {\n      return root.cancelAnimationFrame = function(id) {\n        return clearTimeout(id);\n      };\n    }\n  })(typeof window !== \"undefined\" && window !== null ? window : this);\n\n  indexOf = function(array, match) {\n    var i, item, j, len;\n    if (array == null) {\n      return;\n    }\n    if (Array.prototype.indexOf != null) {\n      return Array.prototype.indexOf.call(Array.prototype.slice.call(array), match);\n    }\n    for (i = j = 0, len = array.length; j < len; i = ++j) {\n      item = array[i];\n      if (item === match) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  extend = function() {\n    var j, len, object, objects, prop, target;\n    target = arguments[0], objects = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (typeof target !== 'object') {\n      return;\n    }\n    for (j = 0, len = objects.length; j < len; j++) {\n      object = objects[j];\n      for (prop in object) {\n        if (!hasProp.call(object, prop)) continue;\n        target[prop] = object[prop];\n      }\n    }\n    return target;\n  };\n\n  clone = function(object) {\n    return extend({}, object);\n  };\n\n  bind = function(fn, context) {\n    return function() {\n      return fn.apply(context, [].slice.call(arguments));\n    };\n  };\n\n  now = (ref = Date.now) != null ? ref : function() {\n    return new Date().getTime();\n  };\n\n  Slideshow = (function() {\n    var animateSlides, defaults, effects, eventEnd, eventProgress, eventStart, init, initEvents, initSlides, nextFrame, preventDefault, setCurrentSlide;\n\n    function Slideshow(element, options) {\n      if (options == null) {\n        options = {};\n      }\n      if (element.nodeType !== 1) {\n        if (element[0] != null) {\n          element = element[0];\n        }\n        if (element.el != null) {\n          element = element.el;\n        }\n      }\n      if (element.nodeType !== 1) {\n        throw new Error('No valid element provided');\n      }\n      this.configure(options);\n      this.el = element;\n      init.call(this);\n    }\n\n    Slideshow.prototype.configure = function(options) {\n      var base;\n      this.options = extend({}, defaults, options);\n      if (typeof this.options.effect === 'string' && (effects[this.options.effect] != null)) {\n        this.options.effect = clone(effects[this.options.effect]);\n        return (base = this.options.effect).conditions != null ? base.conditions : base.conditions = effects[\"default\"].conditions.concat();\n      }\n    };\n\n    defaults = {\n      touchEventsEnabled: true,\n      mouseEventsEnabled: true,\n      swipeThreshold: 0,\n      animationDuration: 400,\n      animationDirection: 'x',\n      effect: 'default'\n    };\n\n    effects = {\n      \"default\": (function() {\n        var transformCSSProperty;\n        transformCSSProperty = (function() {\n          var j, len, prefixed, ref1, style, vendor;\n          style = document.createElement('div').style;\n          if (style['transform'] != null) {\n            return 'transform';\n          }\n          ref1 = ['moz', 'webkit', 'khtml', 'o', 'ms'];\n          for (j = 0, len = ref1.length; j < len; j++) {\n            vendor = ref1[j];\n            prefixed = vendor + \"Transform\";\n            if (style[prefixed] != null) {\n              return prefixed;\n            }\n          }\n          return false;\n        })();\n        return {\n          conditions: [\n            {\n              progress: .1,\n              time: 250,\n              durationModifier: .5\n            }, {\n              progress: .3,\n              time: 500\n            }, {\n              progress: .5\n            }\n          ],\n          before: function(slideState, slideElement) {\n            var X;\n            slideElement.style.display = 'block';\n\n            /*\n            slideState  is either -1, 0 or 1\n            if slideState === 0 then this is the current slide and we want to show it, so set translateX(0)\n            if slideState === -1 then this is the previous slide (to the left) so translateX(-100%)\n            if slideState === 1 then this is the next slide (to the right) so translateX(100%)\n             */\n            X = -slideState * 100;\n            if (transformCSSProperty) {\n              return slideElement.style[transformCSSProperty] = \"translateX(\" + X + \"%)\";\n            } else {\n              return slideElement.style.left = X + \"%\";\n            }\n          },\n          progress: function(slideState, progress, slideElement) {\n\n            /*\n            slideState = either 0 or 1\n            0 <= Math.abs(progress) <= 1, but progress can also be negative.\n            progress < 0 indicates movement to the left\n            progress > 0 indicates movement to the right\n            \n            if slideState === 0 then this is the current slide and we want it to move away as progress increases:\n            X1 = 100 * p where p = progress\n            if slideState === 1 then this is the target slide and we want it to move in from the left/right as progress increases:\n            X2 = 100 * (-p / |p|) * (|p| - 1) where |p| = Math.abs(progress)\n            \n            X = (1 - S) * X1 + S * X2 where S = slideState\n            X is the translateX value that should be set on this slide\n            \n            X = (1 - S) * 100 * p + S * 100 * (-p / |p|) * (1 - |p|)\n            X = 100 * p * ( (1 - S) - S * (1 / |p|) * (1 - |p|) )\n            X = 100 * p * ( 1 - S - S * ( (1 / |p|) - 1 ) )\n            X = 100 * p * ( 1 - S + S * (1 - (1 / |p|) ) )\n            X = 100 * p * ( 1 - S + S - (S / |p|) )\n            X = 100 * p * ( 1 - (S / |p|) )\n             */\n            var X;\n            X = 100 * progress * (1 - slideState / Math.abs(progress));\n            if (transformCSSProperty) {\n              return slideElement.style[transformCSSProperty] = \"translateX(\" + X + \"%)\";\n            } else {\n              return slideElement.style.left = X + \"%\";\n            }\n          },\n          after: function(slideState, slideElement) {\n\n            /*\n            slideState is either 0 or 1\n            if slideState === 0 then this is the previously visible slide and it must be hidden\n            if slideState === 1 then this is the currently visible slide and it must be visible\n             */\n            return slideElement.style.display = slideState > 0 ? 'block' : 'none';\n          }\n        };\n      })()\n    };\n\n    init = function() {\n      initSlides.call(this);\n      return initEvents.call(this);\n    };\n\n    initSlides = function() {\n      var effectAfter, effectBefore, i, j, len, ref1, ref2, ref3, ref4, results, slide;\n      effectBefore = (ref1 = this.options.effect.before) != null ? ref1 : Function.prototype;\n      effectAfter = (ref2 = this.options.effect.after) != null ? ref2 : Function.prototype;\n      this.slides = (ref3 = this.el.children) != null ? ref3 : this.el.childNodes;\n      this.current = 0;\n      ref4 = this.slides;\n      results = [];\n      for (i = j = 0, len = ref4.length; j < len; i = ++j) {\n        slide = ref4[i];\n        if (i !== this.current) {\n          if (i === this.current) {\n            effectBefore.call(this, 0, this.slides[this.current]);\n            results.push(effectAfter.call(this, 1, this.slides[this.current]));\n          } else {\n            effectBefore.call(this, 1, slide);\n            results.push(effectAfter.call(this, 0, slide));\n          }\n        }\n      }\n      return results;\n    };\n\n    initEvents = function() {\n      var j, len, ref1, results, slide;\n      this.eventStart = bind(eventStart, this);\n      this.eventProgress = bind(eventProgress, this);\n      this.eventEnd = bind(eventEnd, this);\n      if ((typeof TouchEvent !== \"undefined\" && TouchEvent !== null) && this.options.touchEventsEnabled) {\n        this.el.addEventListener('touchstart', this.eventStart);\n        this.el.addEventListener('touchmove', this.eventProgress);\n        this.el.addEventListener('touchend', this.eventEnd);\n      }\n      if ((typeof MouseEvent !== \"undefined\" && MouseEvent !== null) && this.options.mouseEventsEnabled) {\n        this.el.addEventListener('mousedown', this.eventStart);\n        this.el.addEventListener('mousemove', this.eventProgress);\n        this.el.addEventListener('mouseup', this.eventEnd);\n        this.el.addEventListener('mouseleave', this.eventEnd);\n        ref1 = this.slides;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n          slide = ref1[j];\n          slide.addEventListener('mousedown', preventDefault);\n          slide.addEventListener('mousemove', preventDefault);\n          results.push(slide.addEventListener('mouseup', preventDefault));\n        }\n        return results;\n      }\n    };\n\n    setCurrentSlide = function(slide) {\n      return this.current = indexOf(this.slides, slide);\n    };\n\n    animateSlides = function(currentSlide, targetSlide, arg, callback) {\n      var direction, duration, durationMod, effectBefore, initialProgress, progress, ref1, ref2;\n      direction = arg.direction, initialProgress = arg.initialProgress, durationMod = arg.durationMod;\n      if (this.currentAnimation != null) {\n        return;\n      }\n      if (!((this.currentEvent != null) && this.currentEvent.cancelOnWillChange)) {\n        if ((ref1 = this.options.onWillChange) != null) {\n          ref1.call(this, currentSlide, targetSlide, modulo(this.current - direction / Math.abs(direction), this.slides.length));\n        }\n      }\n      progress = initialProgress != null ? initialProgress : 0;\n      if (durationMod == null) {\n        durationMod = 1;\n      }\n      duration = Math.max(1, this.options.animationDuration * (1 - progress) * durationMod);\n      if (this.currentEvent == null) {\n        effectBefore = (ref2 = this.options.effect.before) != null ? ref2 : Function.prototype;\n        effectBefore.call(this, 0, currentSlide);\n        effectBefore.call(this, (direction < 0 ? 1 : -1), targetSlide);\n      }\n      this.currentAnimation = {\n        start: now(),\n        currentSlide: currentSlide,\n        targetSlide: targetSlide,\n        direction: direction,\n        duration: duration,\n        progress: progress,\n        callback: callback\n      };\n      return requestAnimationFrame(bind(nextFrame, this));\n    };\n\n    nextFrame = function(timestamp) {\n      var anim, callback, currentSlide, direction, duration, effectAfter, effectProgress, id, progress, ref1, ref2, ref3, ref4, start, targetSlide;\n      id = requestAnimationFrame(bind(nextFrame, this));\n      anim = this.currentAnimation;\n      ref1 = this.currentAnimation, start = ref1.start, progress = ref1.progress, duration = ref1.duration, direction = ref1.direction, currentSlide = ref1.currentSlide, targetSlide = ref1.targetSlide, callback = ref1.callback;\n      progress = progress + (now() - start) / duration * (1 - progress);\n      if (progress >= 1) {\n        progress = 1;\n        this.currentAnimation = null;\n        cancelAnimationFrame(id);\n        effectAfter = (ref2 = this.options.effect.after) != null ? ref2 : Function.prototype;\n        effectAfter.call(this, 0, currentSlide);\n        effectAfter.call(this, 1, targetSlide);\n        setCurrentSlide.call(this, targetSlide);\n        if (typeof callback === 'function') {\n          callback.call(this, currentSlide, targetSlide, this.current);\n        }\n        if ((ref3 = this.options.onDidChange) != null) {\n          ref3.call(this, currentSlide, targetSlide, this.current);\n        }\n        setCurrentSlide.call(this, targetSlide);\n      }\n      effectProgress = (ref4 = this.options.effect.progress) != null ? ref4 : Function.prototype;\n      effectProgress.call(this, 0, progress * direction, currentSlide);\n      return effectProgress.call(this, 1, progress * direction, targetSlide);\n    };\n\n    eventStart = function(event) {\n      var currentSlide, effectBefore, nextSlide, prevSlide, ref1, ref2, ref3, ref4, startX, startY, timeStamp;\n      if ((this.currentAnimation != null) || (this.currentEvent != null)) {\n        return;\n      }\n      currentSlide = this.getCurrentSlide();\n      prevSlide = this.getPrevSlide();\n      nextSlide = this.getNextSlide();\n      effectBefore = (ref1 = this.options.effect.before) != null ? ref1 : Function.prototype;\n      effectBefore.call(this, 0, currentSlide);\n      effectBefore.call(this, -1, prevSlide);\n      effectBefore.call(this, 1, nextSlide);\n      timeStamp = event.timeStamp;\n      ref4 = (ref2 = (ref3 = event.touches) != null ? ref3[0] : void 0) != null ? ref2 : event, startX = ref4.pageX, startY = ref4.pageY;\n      return this.currentEvent = {\n        currentSlide: currentSlide,\n        prevSlide: prevSlide,\n        nextSlide: nextSlide,\n        timeStamp: timeStamp,\n        startX: startX,\n        startY: startY\n      };\n    };\n\n    eventProgress = function(event) {\n      var nextIndex, pageX, pageY, progress, ref1, ref2, ref3, ref4, targetSlide;\n      if (this.currentAnimation || (this.currentEvent == null)) {\n        return;\n      }\n      ref3 = (ref1 = (ref2 = event.touches) != null ? ref2[0] : void 0) != null ? ref1 : event, pageX = ref3.pageX, pageY = ref3.pageY;\n      progress = {\n        x: (pageX - this.currentEvent.startX) / this.el.clientWidth,\n        y: (pageY - this.currentEvent.startY) / this.el.clientHeight\n      };\n      progress = (function() {\n        switch (this.options.animationDirection) {\n          case 'x':\n            if (Math.abs(progress.x) > Math.abs(progress.y)) {\n              return progress.x;\n            }\n            break;\n          case 'y':\n            if (Math.abs(progress.y) > Math.abs(progress.x)) {\n              return progress.y;\n            }\n        }\n      }).call(this);\n      this.currentEvent.shouldCancel = !progress;\n      if (progress == null) {\n        return;\n      }\n      targetSlide = progress < 0 ? this.currentEvent.nextSlide : this.currentEvent.prevSlide;\n      if (targetSlide !== this.currentEvent.targetSlide) {\n        this.currentEvent.cancelOnWillChange = false;\n        this.currentEvent.targetSlide = targetSlide;\n      }\n      if (!(this.currentEvent.cancelOnWillChange && progress !== 0)) {\n        this.currentEvent.cancelOnWillChange = true;\n        nextIndex = modulo(this.current - progress / Math.abs(progress), this.slides.length);\n        if ((ref4 = this.options.onWillChange) != null) {\n          ref4.call(this, this.currentEvent.currentSlide, targetSlide, nextIndex);\n        }\n      }\n      this.currentEvent.targetSlide = targetSlide;\n      return requestAnimationFrame((function(_this) {\n        return function() {\n          var effectProgress, ref5;\n          effectProgress = (ref5 = _this.options.effect.progress) != null ? ref5 : Function.prototype;\n          effectProgress.call(_this, 0, progress, _this.currentEvent.currentSlide);\n          return effectProgress.call(_this, 1, progress, targetSlide);\n        };\n      })(this));\n    };\n\n    eventEnd = function(event) {\n      var condition, currentSlide, direction, durationMod, initialProgress, j, len, pageX, pageY, progress, progressAbs, ref1, ref2, ref3, ref4, ref5, ref6, targetSlide, timePassed, timeStamp;\n      if (this.currentAnimation || (this.currentEvent == null)) {\n        return;\n      }\n      timeStamp = event.timeStamp;\n      ref3 = (ref1 = (ref2 = event.changedTouches) != null ? ref2[0] : void 0) != null ? ref1 : event, pageX = ref3.pageX, pageY = ref3.pageY;\n      progress = (function() {\n        switch (this.options.animationDirection) {\n          case 'x':\n            return (pageX - this.currentEvent.startX) / this.el.clientWidth;\n          case 'y':\n            return (pageY - this.currentEvent.startY) / this.el.clientHeight;\n        }\n      }).call(this);\n      if (this.currentEvent.shouldCancel) {\n        currentSlide = progress > 0 ? this.currentEvent.nextSlide : this.currentEvent.prevSlide;\n        direction = progress / Math.abs(progress);\n        initialProgress = 1 - Math.abs(progress);\n        animateSlides.call(this, currentSlide, this.currentEvent.currentSlide, {\n          direction: direction,\n          initialProgress: initialProgress\n        });\n        this.currentEvent = null;\n        return;\n      }\n      if (progress === 0) {\n        this.currentEvent = null;\n        return;\n      }\n      timePassed = timeStamp - this.currentEvent.timeStamp;\n      progressAbs = Math.abs(progress);\n      ref4 = this.options.effect.conditions;\n      for (j = 0, len = ref4.length; j < len; j++) {\n        condition = ref4[j];\n        if (progressAbs > condition.progress && timePassed < ((ref5 = condition.time) != null ? ref5 : Infinity)) {\n          durationMod = (ref6 = condition.durationModifier) != null ? ref6 : 1;\n          break;\n        }\n      }\n      if (durationMod != null) {\n        currentSlide = this.currentEvent.currentSlide;\n        direction = progress / progressAbs;\n        if (direction === 1) {\n          targetSlide = this.currentEvent.prevSlide;\n        } else {\n          targetSlide = this.currentEvent.nextSlide;\n        }\n        initialProgress = progressAbs;\n      } else {\n        targetSlide = this.currentEvent.currentSlide;\n        direction = -progress / progressAbs;\n        if (direction === 1) {\n          currentSlide = this.currentEvent.nextSlide;\n        } else {\n          currentSlide = this.currentEvent.prevSlide;\n        }\n        initialProgress = 1 - progressAbs;\n      }\n      return animateSlides.call(this, currentSlide, targetSlide, {\n        direction: direction,\n        initialProgress: initialProgress,\n        durationMod: durationMod\n      }, (function(_this) {\n        return function() {\n          return _this.currentEvent = null;\n        };\n      })(this));\n    };\n\n    preventDefault = function(event) {\n      return event.preventDefault();\n    };\n\n    Slideshow.prototype.getSlide = function(i) {\n      return this.slides[modulo(i, this.slides.length)];\n    };\n\n    Slideshow.prototype.getCurrentSlide = function() {\n      return this.slides[this.current];\n    };\n\n    Slideshow.prototype.getCurrentIndex = function() {\n      return this.current;\n    };\n\n    Slideshow.prototype.getNextSlide = function() {\n      return this.getSlide(this.current + 1);\n    };\n\n    Slideshow.prototype.getPrevSlide = function() {\n      return this.getSlide(this.current - 1);\n    };\n\n    Slideshow.prototype.getFirstSlide = function() {\n      return this.slides[0];\n    };\n\n    Slideshow.prototype.getLastSlide = function() {\n      return this.slides[this.slides.length - 1];\n    };\n\n    Slideshow.prototype.goTo = function(i, cb) {\n      var currentSlide, direction, targetSlide;\n      if (i === this.current) {\n        return;\n      }\n      currentSlide = this.getCurrentSlide();\n      targetSlide = this.getSlide(i);\n      direction = i < this.current ? 1 : -1;\n      return animateSlides.call(this, currentSlide, targetSlide, {\n        direction: direction\n      }, cb);\n    };\n\n    Slideshow.prototype.goToNext = function(cb) {\n      return this.goTo(this.current + 1, cb);\n    };\n\n    Slideshow.prototype.goToPrev = function(cb) {\n      return this.goTo(this.current - 1, cb);\n    };\n\n    Slideshow.prototype.goToFirst = function(cb) {\n      return this.goTo(0, cb);\n    };\n\n    Slideshow.prototype.goToLast = function(cb) {\n      return this.goTo(this.slides.length - 1, cb);\n    };\n\n    Slideshow.prototype.destroy = function() {\n      var j, len, ref1, ref2, slide;\n      this.el.removeEventListener('touchstart', this.eventStart);\n      this.el.removeEventListener('touchmove', this.eventProgress);\n      this.el.removeEventListener('touchend', this.eventEnd);\n      this.el.removeEventListener('mousedown', this.eventStart);\n      this.el.removeEventListener('mousemove', this.eventProgress);\n      this.el.removeEventListener('mouseup', this.eventEnd);\n      this.el.removeEventListener('mouseleave', this.eventEnd);\n      ref1 = this.slides;\n      for (j = 0, len = ref1.length; j < len; j++) {\n        slide = ref1[j];\n        slide.removeEventListener('mousedown', preventDefault);\n        slide.removeEventListener('mousemove', preventDefault);\n        slide.removeEventListener('mouseup', preventDefault);\n      }\n      return ref2 = {}, this.el = ref2.el, this.slides = ref2.slides, this.eventStart = ref2.eventStart, this.eventProgress = ref2.eventProgress, this.eventEnd = ref2.eventEnd, this.options = ref2.options, ref2;\n    };\n\n    Slideshow.registerAsJQueryPlugin = function(jQuery, methodName) {\n      if (methodName == null) {\n        methodName = 'Slideshow';\n      }\n      return jQuery.fn[methodName] = function(options) {\n        var container, j, len, results;\n        results = [];\n        for (j = 0, len = this.length; j < len; j++) {\n          container = this[j];\n          results.push(new Slideshow(container, options));\n        }\n        return results;\n      };\n    };\n\n    Slideshow.registerEffect = function(name, effect) {\n      if (effect.conditions == null) {\n        effect.conditions = effects[\"default\"].conditions.concat();\n      }\n      return effects[name] != null ? effects[name] : effects[name] = effect;\n    };\n\n    return Slideshow;\n\n  })();\n\n  (function(root) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], function() {\n        return Slideshow;\n      });\n    } else if (typeof exports !== 'undefined') {\n      return module.exports = Slideshow;\n    } else {\n      return root.Slideshow = Slideshow;\n    }\n  })(this);\n\n}).call(this);\n\n//# sourceMappingURL=slideshow.js.map\n"],"sourceRoot":"/source/"}